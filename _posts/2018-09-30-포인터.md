---
layout: post
title: 포인터
excerpt: "자료의 저장 단위, RAM의 동작 방법, Big/Little indian, 운영 체제, Memory allocation"
tags: []
categories: [Algorithm]
link:
comments: true
pinned: true
image:
  feature: algorithms.png
---

### 포인터

- 컴퓨터 공부에 있어 어려운 요소
  - 포인터(Pointer) : 컴퓨터 내부에 대해 알아야 함
    - 참고로 자바는 포인터가 없다. 참조할만한 비교 자료 링크(https://soul0.tistory.com/89)
  - 재귀호출(Recursion) : 지금까지 생각하던 방법을 확장
- 포인터 : 값을 저장하는 것이 아닌, **값의 위치**를 저장하는 변수
- 변수를 가리키는 역할을 함 (주소의 변수를 담는 변수)
  - int* = int형 변수를 가리키겠다는 것
  - 가리키다 = 변수의 주소를 저장한다.
- 문법 
  - int* x : int형 변수를 가리키는 변수 x
  - &x : x의 주소
  - \*x : x가 가리키는 변수의 값

#### 컴퓨터

포인터(Pointer) : 컴퓨터 내부 중에서도 **저장장치(메모리)**에 관한 것

- 입력장치 : 키보드 / 마우스
- 출력장치 : 모니터 / 오디오
- 연산장치 : 값을 받아서 처리하는(계산하는) 부분
  - 저장
  - 계산

#### 자료의 저장 단위

- 비트(Bit) : 정보의 가장 작은 단위. 0혹은 1을 담음
  - 1비트 - 0혹은 1을 담는 1개의 저장공간
  - 2비트 - 0혹은 1을 담는 2개의 저장공간
  - 8비트 - 0혹은 1을 담는 8개의 저장공간
- 바이트(Byte) : 정보의 기본 단위(사람들이 보통 얘기할 때의 단위). 8개의 비트로 이루어짐.
  - int - 4byte / double - 8byte
- 킬로바이트(KB) : 1000개의 바이트로 이루어짐
- 메가바이트(MB) : 1000개의 KB로 이루어짐
- 기가바이트(GB) : 1000개의 MB로 이루어짐

#### RAM(Random Access Memory)

- 자료를 저장하기 위한 장치
  - 특정 공간에 있는 값을 access하는데 걸리는 시간이 비슷하다. 

![](/img/memory.png)

- 주소의 값은 16진수이다. 메모리는 16진수로 주소 값을 생성한다.

  - 위의 이미지에서 0x를 제외한 뒤의 7ffeed00595c, 7ffeed00595d, 7ffeed00595e…가 주소 값이다. 

- 16진수 : 한 자리에 0부터 15까지 담을 수 있다. = 16개의 숫자를 담기 위해서는 2진수로 4자리가 필요하므로 한 자리마다 1비트, 총 4비트 필요. 

  ![](/img/memory2.png)

- 즉, 16진수로 표현한 값은 한 자리마다 4비트가 필요한 셈이다.

- 위의 주소 값의 자리수는 12자리이므로 4비트 \* 12, 총 48비트가 필요하다. 즉, 메모리 주소 값 하나에 필요한 단위는 48비트.

  ![](/img/memory3.png)

- 우리가 평소에 말하는 32bit, 64bit 운영체제는 메모리 주소 하나의 값에 필요한 단위가 32, 64비트라는 것. 즉 더 길고 많은 주소 값을 저장할 수 있게 된다. 그런데 왜 48bit로만 주소 값을 표현할까? 현재 컴퓨터가 64bit를 쓸 필요가 없어서 48bit만 쓰고 있는 것. 나머지 16bit는 안 쓰고 있는 것이다. (그러나 표현하지 않는 것일 뿐 실제 주소의 크기는 항상 64비트이다.)

- 주의할 것이 정보의 기본 단위는 1바이트다. 즉 메모리 안에는 64bit가 아니라 8byte가 들어가 있는 것. 

  ![](/img/memory4.png)

  즉, 각각의 칸은 48비트로 이루어진 주소 값을 갖는 것이고, 각각의 칸 안에는 1바이트로 나타낸 값, 8비트가 들어가 있는 것이다.

  ![](/img/memory5.png)

- 주소 값은 64bit가 필요하므로 8byte가 필요하다 따라서 주소 값을 저장하는 포인터의 문법인 ```int* myPointer```를 사용할 때는 8Byte가 필요하고 이 8Byte를 이용해서 주소 값을 표현한다. 8Byte를 차지하므로 주소 값부터 총 8칸을 차지하게 된다.

  ![](/img/memory6.png)

- 실제 값을 저장하는 ```int a```는 int형이 4Byte이므로 4칸을 차지하고, 이 4칸의 4Byte를 이용해서 한 개의 숫자 값을 표현하겠다는 얘기이다.

  ![](/img/memory7.png)

  실제 저장을 하면 아래와 같이 값이 바뀐다. 우리의 생각대로라면 맨 마지막 칸에 11이 위치해야할 것 같지만, 실제 컴퓨터는 반대로 실행한다. 즉 맨 밑에칸부터 숫자를 읽어야 한다.

  ![](/img/memory8.png)

- 따라서 위의 개념을 바탕으로 ```myPointer = &a;```를 실행하게 되면, myPointer가 갖고 있는 8바이트의 메모리 칸의 아래부터, 변수 a의 주소 값인 7ffed00595c를 차례로 표현하여 넣게 된다는 것을 알 수 있다.

  ![](/img/memory9.png)

- 자연스럽게 ```*myPointer```를 출력하면 myPointer가 갖고 있는 값인7ffed00595c라는 주소 값이 가지고 있는 값인 3을 출력하고, ```myPointer``` 자체를 출력하면 7ffed00595c 값이 출력된다는 것을 알 수 있다. 

#### Big Endian / Little Endian

컴퓨터는 메모리에 값을 거꾸로 저장한다. 왜 그럴까?

만약 변수 a에 1,342,345라는 값을 넣어 저장한다고 해보자.

컴퓨터가 값을 저장하는 순서에는 크게 두 가지가 있다.

-  Big Endian : 주소가 높을 수록 낮은 자리를 기록

  ![](/img/bigEndian.png)

- Little Endian : 주소가 높을 수록 높은 자리를 기록

  ![](/img/littleEndian.png)

오늘날 x86 아키텍처를 사용하는 대부분의 데스크톱 컴퓨터는 리틀 엔디언을 쓰며 이를 '인텔 포멧'이라고 한다. 거꾸로 네트워크에서는 주소를 빅 엔디언으로 쓰는데, 역사적으로 라우팅이 전화를 거는 식으로 접두 부호로 이루어졌기 때문이다. 이의 영향으로 많은 프로토콜과 몇몇 파일 포맷이 빅 엔디언을 사용하고 있다.

### 운영체제(Operating System)

변수를 선언하게 되면 구체적을 무슨 일이 일어날까? 즉, 특정 공간이 필요할 때 컴퓨터에게 어떻게 요청을하고, 컴퓨터 내에서는 어떤 일이 일어나서 변수를 할당을 하게 되는지에 대해 알아 본다.

이러한 일을 하는 것이 운영체제이다.

운영체제 : 하드웨어를 제어하기 위한 소프트웨어

![](/img/OS.png)

#### 기억장소 할당(Memory Allocation)

- 변수에 값을 담기 위한 과정
  1. 프로그램이 운영체제에게 필요한 공간의 양을 알려준다.
  2. 운영체제가 그 만큼의 공간을 예약한다.(다른 프로그램이 해당 공간을 쓰지 못하게 한다.)
  3. 운영체제가 프로그램에게 해당 공간을 **대표하는 주소**(시작 주소)를 반환한다.

예제1)

1. ```int a;```가 실행되어 변수를 선언하면 운영체제가 임의의 주소를 할당하고 데이터타입 만큼 공간을 예약한다.

   ![](/img/malloc1.png)

2. ```a = 3;```이 실행되면 4바이트로 표현된 3의 값이 들어간다.

   ![](/img/malloc2.png)

예제2)

![](/img/malloc3.png)

위에서 void포인터에 주목해야 한다. void형 주소를 가리키는 포인터인데, 아무것도 반환하지 않는 데이터 타입에 대한 포인터는 왜 필요하고, 만약 필요하다면 이 void포인터의 데이터 크기는 어떻게 할당하는가? 

* int\*를 쓴다면 int의 데이터 타입의 크기가 4바이트이므로 malloc(4)가 필요하다. ```int* x = malloc(4);```
* character\*를 쓴다면 character의 데이터 타입의 크기가 1바이트이므로 malloc(1)가 필요하다. ```character* x = malloc(1);```
* double\*를 쓴다면 double의 데이터 타입의 크기가 8바이트이므로 malloc(8)가 필요하다. ```double* x = malloc(8);```

위의 세 가지 경우를 모두 사용한다면 매번 데이터 타입에 따라 malloc의 인자가 바뀌어야한다. 따라서 각 데이터타입마다 malloc을 따로따로 만들어서 사용해야하는데, 같은 내용의 함수를 데이터 타입마다 따로 만들어서 사용하는 것은 굉장히 비효율적이다.그런데 아래와 같이 사용자가 원하는 타입으로 형변환을 하면서 사용할 수 있다면, malloc함수를 여러번 정의할 필요가 없다. 이렇게 사용자가 형 변환을 할 수 있게 하기 위해 void*를 사용하는 것이다. 이렇게 되면 malloc은 공간 할당만 하면 될 뿐, 공간을 사용하려고 하는 변수의 데이터 타입이 무엇인지는 몰라도 된다.

~~~c++
int* a; 
a = (int*)malloc(4);
~~~

![](/img/malloc4.png)

예제3)

~~~c++
int* a;
a = (int*)malloc(8);

*a = 10;
*(a+1) = 20;

printf("%d\n",*a);
printf("%d\n",*(a+1));

return 0;
~~~

위의 예제에서 int형은 4바이트만 필요한데 왜 예제에서는 8바이트를 넣었는지에 대해 알아보자.

int형이 4바이트이므로 a에 할당된 공간 중 4바이트가 남는다. 이 때, a가 갖고 있는 주소 값에 +1을 하고 20을 할당하면 어떻게 될까? 1바이트 다음 칸 주소의 메모리가 아니라, int형의 데이터 크기인 4바이트 다음 칸의 주소 메모리에 20이 저장된다.

![](/img/malloc5.png)

만약 데이터 타입이 character였다면 1바이트 다음 칸 주소가 가리키는 메모리에 문자가 저장되었을 것이고, double이었다면 실수가 8바이트 다음 칸 주소가 가리키는 메모리에 실수가 저장되었을 것이다. 결국 주소 값에 +1을 하는 것은 데이터형의 데이터 크기 만큼 이동하는 것과 같다.

이러한 과정이 바로 배열의 원리이다.

![](/img/malloc6.png)

실제 코드로 보면

~~~c++
#include <stdio.h>
#include <stdlib.h>

int main(){
	int* a;
	a=(int*)malloc(sizeof(int)*10);   
    
    *a=10;
    *(a+1)=20;
    *(a+2)=30;
    
    printf("%d\n",*a); //10
    printf("%d\n",*(a+1)); //20
    printf("%d\n",*(a+2)); //30
}
~~~

위의 코드는

~~~c++
#include <stdio.h>
#include <stdlib.h>

int main(){
	int* a;
	a=(int*)malloc(sizeof(int)*10);   
    
    *a=10;
    *(a+1)=20;
    *(a+2)=30;
    
    printf("%d\n",a[0]); //10
    printf("%d\n",a[1]); //20
    printf("%d\n",a[2]); //30
}

int main(){
	int* a;
	a=(int*)malloc(sizeof(int)*10);   
    
    a[0]=10;
    a[1]=20;
    a[2]=30;
    
    printf("%d\n",*a); //10
    printf("%d\n",*(a+1)); //20
    printf("%d\n",*(a+2)); //30
}

int main(){
	int a[10]; //이렇게 선언해도 결국 a가 int*의 포인터가 되는 것이다.
    
    a[0]=10;
    a[1]=20;
    a[2]=30;
    
    printf("%d\n",a[0]); //10
    printf("%d\n",a[1]); //20
    printf("%d\n",a[2]); //30
}

~~~

위의 모든 코드와 정확히 같다.

결국 malloc() 함수는 배열을 실제로 구현하기 위한 함수였던 것이다. 포인터를 이해하지 못한다면 배열이 어떻게 구현되어있는지를 알 수가 없다. 포인터와 배열을 다르게 생각하는 것이 아니라, 근본적으로 같은 것이라는 것을 이해하고 서로 자유자재로 바꾸면서 사용할 수 있어야한다.

~~~c++
#include <stdio.h>
#include <stdlib.h>

int main(){
	int a[10];
    
	a[0]=10;
    
    printf("%d\n",*a); //10
    
    printf("%d\n",a); //메모리 주소 값
    printf("%d\n",a+1); //a의 메모리 주소 값 +4 바이트 뒤의 주소 값
    
    printf("%d\n",&a[0]); //메모리 주소 값
    printf("%d\n",&a[1]); //a의 메모리 주소 값 +4 바이트 뒤의 주소 값
}
~~~



포인터의 작동 원리는 꼭 이해하야하지만, 굳이 어렵게 사용할 필요는 없다. 더 쉽게 사용할 수 있는 변수 선언 방법을 사용하는 것이 올바른 방법이다.