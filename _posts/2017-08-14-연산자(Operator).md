---
layout: post
title: 연산자(Operator)
excerpt: "이전에 배웠던 변수들을 가지고 하는 연산"
categories: [java]
link:
comments: true
---

<h3>1. 연산자와 피연산자</h3>

>연산자(operator): 연산을 수행하는 기호(+,-,*,/등)
>피연산자(operand): 연산자의 작업 대상(변수,상수,리터럴,수식)
* 연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.

<h3>2. 식</h3>

>식(expresiion): 연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것
>식을 평가(evaluation)한다: 식을 계산하여 결과를 얻는 것

<h3>3. 연산자의 종류와 우선순위</h3>

![Smithsonian Image](http://cfile239.uf.daum.net/image/1525EA4C5021BEDE196B3B)<br />
* (타입)은 '형변환 연산자'를 의미한다.
* 피연산자의 개수에 따라 단항, 이항, 삼항을 분류
* 연산자의 기능에 따라 산술, 비교, 논리, 대입을 분류
* 우선순위가 확실하지 않다면 먼저 계산되어야하는 부분을 괄호로 묶는 것이 확실하고 가독성도 좋다.
* 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
* 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
* 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

<h3>4. 산술 변환</h3>

이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야 한다. 대부분의 경우, 두 피연산자의 타입 중에서 더 큰 타입으로 일치시키는데 작은 타입으로 형변환하면 원래의 값이 손실될 가능성이 있기 때문이다. 변수의 형변환과 같은 개념이다.

일반 산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
>두 피연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치)
>피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.

<h3>5. 연산자 종류</h3>

<h5>1. 단항 연산자</h5>

  * ++(증가 연산자): 피연산자를 1증가 시킨다
  * --(감소 연산자): 피연산자를 1감소 시킨다
  * +, - (부호 연산자): 피연산자가 음수면 '-'를 앞에 붙이고 양수면 '+'를 붙인다. 부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용이 가능하다. 덧셈, 뺄셈의 사칙 연산자와는 피연산자의 개수로 구별한다.

<h5>2. 산술 연산자</h5>

  * +, -, *, / (사칙 연산자): 설명 생략

피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다. 만일 0으로 나누면, 컴파일은 정상적으로 되지만 실행 시 오류(ArithmeticException)가 발생한다.

부동 소수점값인 0.0f, 0.0d로 나누는 것은 가능하지만 그 결과는 Infinity(무한대)이다. 나눗셈 연산자 '/'와 나머지 연산자'%'의 피연산자가 무한대(Infinity)또는 0.0인 경우의 표는 아래와 같다.

![Smithsonian Image](https://i0.wp.com/www.javachobo.com/images/p3_6.gif)<br />

<h5>3. 나머지 연산자</h5>

  * % : 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 남은 나머지 값을 결과로 반환하는 연산자. 나눗셈에서처럼 나누는 수(오른쪽 피연산자)로 0을 사용할 수 없고, **피연산자로 정수만 허용한다.**

<h5>4. 비교 연산자</h5>

  * <, >, <=, >= (대소 비교 연산자)
      \> : 좌변 값이 크면, true 아니면 false
      < : 좌변 값이 작으면, true 아니면 false
      \>= : 좌변 값이 크거나 같으면, true 아니면 false
      <= : 좌변 값이 작거나 같으면, true 아니면 false
  * ==, != (등가 비교 연산자)
      == : 두 값이 같으면 true, 아니면 false 반환
      != : 두 값이 다르면 true, 아니면 false 반환
  * 문자열의 비교: 두 문자의 내용이 같은지를 비교할 때는 '==' 대신 equals()라는 메서드를 사용해야 한다. '=='는 서로 다른 객체면 false를 반환하기 때문이다. (String은 클래스이므로 같은 내용일지라도 다른 참조 변수명을 사용하여 객체를 생성하면 서로 다른 객체가 된다. 즉, 내용만 같을 뿐 참조하는 주소는 다른 객체인 것. 패스워드는 같은데 아이디는 다른 것이라고 생각하면 이해가 쉽다.)

<h5>4. 논리 연산자</h5>

  * &&, ||, !
    ||(OR결합) : 피연산자 중 어느 한 쪽만 true이면 true를 결과로 얻는다
    &&(AND결합) : 피연산자 양쪽 모두 true이어야 true를 결과로 얻는다.
    ! (논리 부정 연산자) : 피연산자가 true이면 false를, false면 true를 결과로 반환한다.

![Smithsonian Image](http://cfile4.uf.tistory.com/image/2725BB4256A8F7F4359EEA)<br />

  * &, |, ^, ~, <<, >>
    비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피연산자를 이진수로 표현했을 때의 각 자리를 규칙에 따라 연산을 수행한다. 피연산자로 실수는 허용하지 않고 정수(문자 포함 : 컴퓨터는 문자도 숫자로 인식하고 연산하므로)만 허용된다.
    |(OR연산자) : 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 반환한다. 그 외에는 0을 반환한다.
    &(AND연산자) : 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
    ^(XOR연산자) : 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.
    !(비트 전환 연산자) : 이 연산자는 피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꾼다. 논리부정 연산자'!'와 유사하다.
    <<(쉬프트 연산자) : 피연산자의 각 자리를 2진수로 표현했을 때, 왼쪽으로 한칸 씩 이동 => 피연산자가 양수, 음수일 경우 모두 빈칸은 0으로 채운다. (x<<n은 x*2^n의 결과와 같다.)
    \>>(쉬프트 연산자) : 피연산자의 각 자리를 2진수로 표현했을 때, 왼쪽으로 한칸 씩 이동 => 피연산자가 양수일 경우 빈칸은 0으로 채운다.(2진수 맨 앞자리는 부호비트 이기 때문에 왼쪽 피연산자가 음수인 경우는 빈자리를 1로 채운다.) (x<<n은 x/2^n의 결과와 같다.)

![Smithsonian Image](http://cfile10.uf.tistory.com/image/183EDD365090D094156F3C)<br />

<h5>6. 그 외 연산자</h5>

  * ? (조건 연산자)
    조건식 ? 식1 : 식 2
    위와 같은 형태를 삼항 연산자라고 하며 조건식의 결과가 true면 식1이, false이면 식2가 연산결과가 된다.

  * = (대입 연산자)
    오른쪽 피연산자의 값(식이라면 평가값)을 왼쪽 피연산자에 저장한다. 그리고 저장된 값을 연산결과로 반환한다.

  * op(다른 연산자들) + = (복합 대입 연산자)

![Smithsonian Image](http://cfile209.uf.daum.net/image/2353EF435430FAD7080B44)<br />
