---
layout: post
title: 알고리즘 기초 지식(JAVA)
excerpt: "시간 복잡도, ==와 equals()의 차이, 배열 선언, Collection사용법, HashMap 사용법"
tags: [Java, Algorithm, Basic]
categories: [Algorithm]
link:
comments: true
pinned: true
image:
  feature:

---



## Today's Algorithm

### 자바 코딩 인터뷰 준비 강의 정리

#### 1. 시간 복잡도

면접에서 해당 문제의 시간 복잡도는 어떻게 되나요? -> 더 효율적인 방법은 없을까요? 어떻게 구현해야할까요? 코드로 작성해보시겠어요? -> 개선된 코드의 시간 복잡도는 얼마나 좋아졌나요? 

이런 형식으로 물어보는 경우가 빈번하다. 

기준은 빅오 표기법이다. 빅오의 엔제곱이다라고 대답을 하는 것이 옳다.

```java
//O(n) n이 10이면 10번 돈다. n이 10배 증가하면 10배 더 돈다.
for(int i=0; i<a.length; i++){
    sum += a[i];
}

//O(n^2) n이 10이면 100번 돈다. n이 10배 증가하면 100배 더 돈다.
for(int i=0; i<a.length; i++){
    for(int k=0; k<a.length; k++){
        sum += a[i] + a[k];        
    }
}
```

암기해야 할 부분

- Binary Search(이분 검색 - 정렬된 배열이 들어왔을 때, 반 씩 좁혀나가면서 찾는 방법) : O(logn) -> 이분 검색을 n번했다면 logn을 n번 수행한 것이므로 O(nlogn)이라고 대답해야 한다.
- Quick Sort (빠른 정렬)
  - 평균 : O(nlogn) - 함수 한 줄로 되어있어도 기본적으로 정렬은 O(nlogn)이다.
  - 최악 : O(n^2) - 이런 경우가 발생하지 않게 보통 앞에서 suffling을 한다.
- Bubble Sort, Insertion Sort(느린 정렬) : O(n^2)

#### 코딩할 때, 자기 자신이 먼저 시간 복잡도를 분석하는 연습을 해봐야한다!

#### 2. ==와 equals()의 차이

자바에서 두 개를 비교하는 연산자가 두 가지가 있어서 이 차이를 모르는 경우가 많다.

![](/img/2018-03-30-1.png)

== 는 다른 객체를 가르킬 때 false를 반환한다.

그러나 equals()는 값만을 비교하므로 true를 반환한다.

시험 때 헷갈릴 수 있는 부분이므로 꼭 차이점을 잘 알아두자.

#### 3. 배열 선언하기

면접 때 배열 선언조차 못해서 떨어지는 사람이 굉장히 많다. 긴장하면 생각이 안날 수도 있다. 기초 문법을 반드시 숙지해야한다.

웬만하면 다 integer 배열이다.

```java
int[] array1 = new int[10]; //10은 사이즈
```

캐릭터 배열도 은근 많이쓰인다. 문제에 String이 주어졌을 때 함수를 짜라고 할 때가 있는데, 이 때 배열로 변환해야하는 경우가 자주 있다. 이 때 많이 쓰인다.

```java
char[] array2 = "Good".toCharArray(); //character array로 바꿀 수 있다.
```

#### 4. Collection 사용법

자바에서는 여러가지 Collection을 제공하고, 시험 볼 때 활용해야할 경우가 많이 생긴다. 그런데 잘 모르는 경우가 있다. 

- ArrayList
- LinkedList
- Stack
- Queue
- HashMap (여기부터는 조금 어려워 진다. 하지만 많이 나온다.)
- HashSet (기본적으로는 HashMap으로 되어 있다.)
- PriorityQueue (등장했다고 하면 까다롭다.)

#### 5. HashMap 사용법

HashMap은 특정 섹션에 속하기가 어려워서 미리 알고 문제를 풀어보는 것이 좋다.

![](/img/2018-03-30-02.png)

HashMap은 Java util 패키지에 있다. 온라인 코딩 시 import해야하는 경우도 있으므로 알아두어야한다. HashMap은 Class다. 오른쪽 부분에서는 Map이 interface고 아래 HashMap, TreeMap은 Class이다. 기본적으로 사용법은 거의 같다. 차이가 있다면 TreeMap은 정렬이 된다. 그러나 대부분의 문제는 HashMap으로 풀이가 가능하다. 속도도 HashMap이 좀 더 빠르다.

#### 6. 대략적인 2의 제곱 수 알아두기

코딩인터뷰인데 갑자기 왠 2의 제곱 수? 밀접한 연관이 있다. 코딩 면접이나 전화 면접에서 어림 짐작이 필요한 경우가 있다. 이럴 때 아무런 연관이 없는 것이 아니므로, 이러한 2의 제곱 수에 대한 것은 미리 숙지해야한다.

예) 입력 데이터가 6만 4천개 목록이 2개 들어오고 모든 조합을 확인 한다면?

![](/img/2018-03-30-03.png)

여기서 물결표는 대략적으로 나타낸 것을 의미한다. 즉 1000의 2제곱은 2의 10제곱인 1024의 2제곱과 유사하므로 1000을 2의10제곱으로 변환하여 생각하는 것이다.

그리고 마지막에 2의 32제곱을 2의 2제곱과 2의 30제곱으로 나누는 것은 2의 10제곱이 1024로 1KB이므로 2의 30제곱은 1GB와 같다고 생각하는 것(2의 20제곱 = 1MB, 2의 30제곱 = 1GB)이다. 그래서 조합 하나가 1byte라고 생각한다면 최소 메모리가 4GB가 필요하다고 보는 것.

배열에 저장할 경우 32비트 int로 인덱싱 할 수 있다.

하나의 조합이 int 2개로 이뤄져 8byte라면(interger 하나는 4byte) 32GB(8byte x 4GB)가 최소로 필요하다.

메모리 제한이 4GB로 조건이 주어졌다면 제한은 4GB인데 32GB가 필요하므로 어떻게하면 이 차이를 메꿀 수 있을지에 대해 생각해보고 메모리를 효율적으로 쓰는 방법을 묻는 문제이다.

![](/img/2018-03-30-04.png)