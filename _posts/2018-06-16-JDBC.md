---
layout: post
title: JDBC
excerpt: ""
tags: [Boostcourse]
categories: [Spring]
link:
comments: true
pinned: true
image:
  feature: spring.png
---

이 강의는 connect 재단의 boostcourse 강의를 공부 목적으로 정리한 것입니다.



# JDBC(Java DataBase Connectivity)

자바 언어와 데이터베이스를 연결하는 통로라고 직역하면 이해하기 쉽다.



## **JDBC 개요**

- JDBC(Java Database Connectivity)의 정의
  \- 자바를 이용한 데이터베이스 접속과 SQL 문장의 실행, 그리고 실행 결과로 얻어진 데이터의 핸들링을 제공하는 방법과 절차에 관한 규약
  \- 자바 프로그램 내에서 SQL문을 실행하기 위한 자바 API
  \- SQL과 프로그래밍 언어의 통합 접근 중 한 형태
- Database 학습할 때 sql을 이용해서 DB에 직접 값을 넣거나 조회하는 것들을 수행했었다. 그런데 웹을 동작시킬때는 매번 수행할 때마다 sql로 넣을 수 없다. 따라서 프로그램이 이 과정을 대신하게 해야하는데, 그것이 바로 JDBC다.
- JAVA는 표준 인터페이스인 JDBC API를 제공. 따라서 표준 인터페이스가 이미 구현이 되어있으므로 어떤 데이터베이스 벤더든 상관없이 똑같은 방법으로 사용하기 때문에 사용하기가 편리하다.
- 데이터베이스 벤더, 또는 기타 써드파티에서는 JDBC 인터페이스를 구현한 드라이버(driver)를 제공한다. 우리는 이런 드라이버를 이용하기만 하면 된다.



## **JDBC 환경 구성**

- JDK 설치
- JDBC 드라이버 설치
  \- Maven에 다음과 같은 의존성을 추가한다. MySQL사이트에서 다운로드 한다.

```
<dependency>   
  <groupId>mysql</groupId>   
       <artifactId>mysql-connector-java</artifactId>
       <version>5.1.45</version>
 </dependency>
```

- [Java API Reference 참고 바로가기](https://docs.oracle.com/javase/8/docs/api/)
- [JDBC Tutorial 참고 바로가기](https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html)



## **JDBC를 이용한 프로그래밍 방법**

JDBC를 사용하겠다는 것은 database를 사용하겠다는 것이다. 

우리가 기존에 database를 사용했던 방법 :

 	1. DB에 접속 ```mysql -u유저명 -p 데이터베이스명```
	2. 쿼리문 작성 ```select * from 테이블명```
	3. 작성한 쿼리문 실행
	4. DB가 결과값을 나에게 보여준다.

이전에 DB를 공부할 때 거쳤던 위의 방법쳐럼 JDBC 프로그래밍도 위와 같은 과정을 똑같이 거쳐야한다. 

	1. import java.sql.*;
	2. 드라이버를 로드 한다. (3번의 Connection객체, 4번의 Statement 객체는 데이터베이스마다 구현하는 객체를 말하는 것이다. Connection과 Statement 은 인터페이스고 데이터베이스에 따라서 Connection, Statement 인터페이스를 구현하고있는 객체가 다르다. 이 객체들을 사용하려면 각각 데이터베이스 벤더가 제공하는 라이브러리를 사용할 수 있어야 하는데, 드라이버를 로드하는 과정이 이 라이브러리를 사용할 수 있게 해주는 과정이다. 따라서 3번 이전에 2번이 필수적으로 일어나야 된다.)
	3. Connection 객체를 생성한다. (DB 접속)
	4. Statement 객체를 생성 및 질의 수행 (쿼리문 생성 및 실행)
	5. SQL문에 결과물이 있다면 ResultSet 객체를 생성한다.
	6. 모든 객체를 닫는다. (항상 마지막에 접속을 끊어야한다.)

**JDBC 클래스의 생성 관계**

[![img](http://mooc.phinf.nhnnext.org/20180201_49/1517475141729UGWfv_PNG/2_11_1_JDBC_.PNG?type=w760)](http://www.edwith.org/boostcourse-web/lecture/16734/#)

드라이버 로딩할 때 DriverManager라는 객체의 메서드를 이용해서 드라이버를 로딩한다.

그리고 DriverManager를 이용해서 Connection 인스턴스를 얻어낸다.

Connection 인스턴스를 통해서 Statement 객체를 얻어낸다.

Statement 객체를 통해서 ResultSet을 얻어낸다.

- **JDBC클래스의 생성단계**


**JDBC 사용 - 단계별 설명**

1. IMPORT

자바 코드에서 다른 패키지에 있는 클래스를 사용하기 위해서는 import를 해야한다. java.sql 패키지 안에는 DriverManager, Connection, Statement 등의 인터페이스가 다 들어있다.

```
import java.sql.*;
```

2. 드라이버 로드

각각 DB벤더에서 제공하는 객체이다. 패키지명.클래스명 이다. 어떤 DB를 사용하느냐에 따라 인자 값이 달라질 것이다.

Class객체의 forName() 메서드를 이용하면 해당 객체가 메모리에 올라간다. 실제 객체 생성할 때 new연산자로 객체 생성하는 것과 유사하다고 생각하면된다.

```
Class.forName( "com.mysql.jdbc.Driver" );
```

3. Connection 얻기

Connection 객체를 얻어낼 때 사용하는 객체가 DriverManager이다. DriverManager의 getConnection() 메서드를 이용해서 DB의 url, DB의 user, password를 입력해서 접속한다. DB url을 얻는 방식도 어떤 DB를 사용하느냐에 따라서 다르다.

```
String dburl  = "jdbc:mysql://localhost/dbName";

Connection con =  DriverManager.getConnection ( dburl, ID, PWD );
```

소스코드 예제

오라클을 이용했을 때의 예제이다.

```
public static Connection getConnection() throws Exception{
	String url = "jdbc:oracle:thin:@117.16.46.111:1521:xe";
	String user = "smu";
	String password = "smu";
	Connection conn = null;
	Class.forName("oracle.jdbc.driver.OracleDriver");
	conn = DriverManager.getConnection(url, user, password);
	return conn;
}
```

4. Statement 생성

명령을 생성해야 한다. 실제 쿼리를 사용하면된다.  con(Connection객체)에서 createStatement() 메서드를 사용해서 Statement 객체를 얻어낸다.

```
Statement stmt = con.createStatement();
```

5. 질의 수행

Statement객체를 얻어냈으면 쿼리문을 작성하고 executeQuert()메서드를 통해 실행한다. 하지만 실행하는 쿼리문 종류에 따라서 쿼리 수행 메서드가 조금씩 달라진다.

```
ResultSet rs = stmt.executeQuery("select no from user" );

참고
stmt.execute(“query”);             //any SQL
stmt.executeQuery(“query”);     //SELECT
stmt.executeUpdate(“query”);   //INSERT, UPDATE, DELETE
```

6. ResultSet으로 결과 받기

ResultSet으로 부터 결과값을 얻어오면된다. 실제 ResultSet은 DB가 가지고 있다. 이 DB resultSet의 참조 값을 얻어온 것 후 실행하는 것이다. ResultSet을 DB가 가지고 있는 이유는 실제 쿼리문을 실행했을 때 결과가 10,000건인데 이 결과를 한번에 모두 서버로 가지고 오게 되면 부하가 극심해지므로 DB에 결과 값은 놔두고 참조 값만 가지고 와서 re.next()를 통해 하나씩 꺼내온다.

```
ResultSet rs =  stmt.executeQuery( "select no from user" );
while ( rs.next() )
      System.out.println( rs.getInt( "no") );
```

7. Close

반드시 순서를 거꾸로해서 순차적으로 닫아야한다.

```
rs.close();

stmt.close();

con.close();
```

소스코드 예제

리스트를 꺼내는 코드

```
public List<GuestBookVO> getGuestBookList(){
		List<GuestBookVO> list = new ArrayList<>();
		GuestBookVO vo = null;
		Connection conn = null; //접속
		PreparedStatement ps = null; //명령 수행을 위한 객체 얻기
		ResultSet rs = null; //결과값 얻기
		try{
			conn = DBUtil.getConnection(); //접속. 실제 접속 코드는 빼놓음
			String sql = "select * from guestbook";
			ps = conn.prepareStatement(sql);//쿼리 만들기
			rs = ps.executeQuery();// 쿼리 실행
			while(rs.next()){//결과 꺼내오기
				vo = new GuestBookVO();
				vo.setNo(rs.getInt(1));
				vo.setId(rs.getString(2));
				vo.setTitle(rs.getString(3));
				vo.setConetnt(rs.getString(4));
				vo.setRegDate(rs.getString(5));
				list.add(vo);
			}
		}catch(Exception e){
			e.printStackTrace();
		}finally {
			DBUtil.close(conn, ps, rs);//접속 해제. 실제 해제 코드는 빼놓음
		}		
		return list;		
	}
```

소스코드 예제

한 건 입력하는 코드

```
public int addGuestBook(GuestBookVO vo){
		int result = 0;
		Connection conn = null; //접속
		PreparedStatement ps = null;//명령 수행을 위한 객체 얻기
		try{
			conn = DBUtil.getConnection(); //접속
			String sql = "insert into guestbook values("
					+ "guestbook_seq.nextval,?,?,?,sysdate)";
			ps = conn.prepareStatement(sql);//쿼리 수행을 위한 객체 얻기
			ps.setString(1, vo.getId());
			ps.setString(2, vo.getTitle());
			ps.setString(3, vo.getConetnt());
			result = ps.executeUpdate();//실행
		}catch(Exception e){
			e.printStackTrace();
		}finally {
			DBUtil.close(conn, ps);//접속 해제
		}
		
		return result;
	}
```

소스코드 예제

접속 해제 코드도 매번 사용하는 것을 볼 수 있다.

```
public static void close(Connection conn, PreparedStatement ps){
		if (ps != null) {
			try {
				ps.close();
			} catch (SQLException e) {e.printStackTrace(); }
		}
		if (conn != null) {
			try {
				conn.close();
			} catch (SQLException e) {e.printStackTrace();}
		}
	}
```



여기서 JDBC를 직접 만들어보는 것을 하지 않는 이유는 이번 과정에서는  JDBC를 직접 사용하는 것이아니라 Spring JDBC라는 프레임워크를 사용하기 때문이다. 프레임워크를 사용한다고 하더라도 어떤 식으로 실행이 되는 지를 알고 있는 상태에서 프레임워크를 사용하면 문제가 발생했을 때 해결하기가 쉽다.



------

**생각해보기**

java.sql패키지를 보면 대부분이 interface로 되어 있는 것을 알 수 있습니다.

이를 실제로 구현하는 것은 DBMS를 만든 회사입니다.

java.sql외에 JAVA가 인터페이스만 대부분 제공하는 패키지는 또 어떤 것이 있을까요?

참고로 XML문서의 표준은 w3c에서 정합니다.

------

**참고 자료**

- **[참고링크] Java API Reference**<https://docs.oracle.com/javase/8/docs/api/>


- **[참고링크] JDBC Tutorial**<https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html>