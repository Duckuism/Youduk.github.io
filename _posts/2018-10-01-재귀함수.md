---
layout: post
title: 재귀함수
excerpt: ""
tags: []
categories: [Algorithm]
link:
comments: true
pinned: true
image:
  feature: algorithms.png
---

## 재귀함수

컴퓨터 전반적으로 가장 중요한 개념. 처음 배울 때 제대로 배워야한다.

재귀함수는 일단 함수이므로 함수를 복기해본다.



### 함수

* 값을 입력받아 특정 연산을 수행하여 결과를 반환
* 기본 형태
  * 반환 형, 함수 이름, 인자, 값 반환
* 스코프는 함수간 작업의 완벽한 분담을 위해 존재한다.
* 의미단위의 프로그래밍을 해야한다. 
  * 문제 해결을 위해 어떤 일을 하는 함수가 필요한지를 설계



### 재귀함수

* 자기 자신을 부르는 함수

그럼 재귀함수는 언제 쓰나?



### 재귀함수가 의미있는 예제 ver.1

~~~C++
//getFactorial(n) : n!을 반환하는 함수
int getFactorial(int n){
    if(n == 0)
        return 1;
    else
        return n * getFactorial(n-1);
}

int main(){
    int n;
    scanf("%d", &n);
    prinf("%d\n", getFactorial(n));
}
~~~

주의해서 봐야하는 것

1. getFactorial(n)이 getFactorial(n-1)을 기다리고 있다.
2. gerFactorial(n)과 getFactorial(n-1)의 scope는 다르다.



### 재귀함수를 이해하기 위한 질문

* 재귀함수의 의미는 무엇인가? 도대체 이걸 왜 쓰는 것인가?와 같은 질문은 재귀함수가 왜 필요한지를 몰라서 나오는 질문이다. 따라서 재귀함수의 의미에 대해 알아본다.
* 재귀함수를 만들기 위해서는 어떤 절차를 따라야 하나?



### 재귀함수의 의미

* 귀납적 계산 방법 (귀납적 문제해결 방법)
  * 귀납적이 무엇일까?



### 두 가지 계산 방법

* 순차적 계산법 (지금까지 해왔던 방법)
  * A를 계산한다.
  * A를 이용해서 B를 계산한다.
  * B를 이용해서 C를 계산한다.
  * C를 이용해서 D를 계산함으로써 원하는 결과를 얻는다.
  * ex) 4의 약수의 개수를 구하라.
    * C에 9을 넣는다.
    * 4가 1로 나누어 떨어지면 C에 1을 더한다.
    * 4가 2로 나누어 떨어지면 C에 1을 더한다.
    * 4가 3으로 나누어 떨어지면 C에 1을 더한다.
    * 4가 4로 나누어 떨어지면 C에 1을 더한다.
* 귀납적 계산법 (지금까지 해왔던 모든 계산 방법과 다른 새로운 방법)
  * 구하려고 하는 값을 f(x)라고 하자.
  * **f(x)를 구하기 위하여 또 다시 f(x)를 활용한다.**
    * 대표적인 예제 : $$f(n) = n * f(n-1)$$
    * 우리는 보통 factorial의 정의를 $$n!=1*2\cdot\cdot\cdot*n$$이라고  알고 있지만, 네이버, 위키피디아에는 정의가 전혀 이렇게 되어있지 않다. factorial의 정의는 $$n!=n*(n-1)!$$라고 나와 있다.
    * $$n!=n*(n-1)!$$ 정의가 귀납적으로 계산한 진짜 정의 이고, 이 정의를 순차적으로 바꾼 계산이 $$n!=1*2\cdot\cdot\cdot*n$$일 뿐이다. 
    * $$f(5)=5*f(4)=5*4*f(3)=5*4*3*f(2)=5*4*3*2*f(1)=5*4*3*2*1*f(0)$$이렇게 계산하다 보면 어디까지 계산해야하는지 알 수가 없다. 따라서 **<u>귀납적으로 계산하는 모든 방법은 멈춰야하는 부분이있다.</u>** 이 부분도 factorial에 정의가 되어 있다.
    * 종료 시점을 나타낸 $$f(0)=1$$이 추가된 $$f(n) = n * f(n-1), f(0)=1$$가 진짜 factorial의 정의인 것. 이 때, $$f(0)$$이 1인 것에 대한 이유는 없다. 그냥 공리인 수학적 정의일 뿐이다.  
  * **'나'를 계산하기 위해 또 다시 '나'를 활용한다.**



### 귀납적 계산법의 깊은 이해

하지만 여전히 왜 필요한거지? 에 대한 질문에는 대답이 모호하다. 다른 예제를 살펴본다.

* 예제 2 : $$n^m$$ 을 귀납적으로 계산하여라
  * 정의가 두 가지 나와야한다는 것을 기억해야한다. 한 가지는 나를 다시 활용하는 부분이 포함된 식에 대한 정의, 다른 한 가지는 종료 시점에 대한 정의이다.
  * 귀납적으로 $$n^m$$을 정의한 식 : $$n^m=n^{m-1}*n$$
  * $$5^4 = 5^3*5$$에서  $$5^4$$의 값이 제대로 $$5$$를 4번 곱한 값으로 나오려면 $$5^3$$이 $$5$$를 3번 곱한 값이다라는 **가정**이 있어야 한다. 즉, '$$5^3$$이 5를 3번 곱한다면, $$5^4$$이 5를 4번 곱한다.'가 성립이 되는 것이다.
  * 여기서 가정의 관계가 나오는 것이다. $$5^4$$이 $$5$$를 4번 곱한 값으로 나오려면 $$5^3$$은 $$5$$를 3번 곱한 값이다라는 **가정**이 **성립**해야하는 것. 그러면 우리는 $$5^3$$이 제대로 5를 3번 곱한다면 $$5^4$$이 제대로 성립을 한다는 것을 알고 있으므로, $$5^3$$이 정말로 5를 3번 곱하는 지에 대해서만 초점을 맞추면 된다. 그런데 $$5^3$$이 제대로 계산되는 지를 보려면 $$5^2$$이 5를 2번 곱한 값이라는 가정이 있어야 하고, $$5^2$$이 5를 2번 곱한 값이 맞다면 $$5^3$$ 의 연산도 성립할 것이므로 $$5^2$$가 정말로 5를 2번 곱한 것인지에 대해서만 초점을 맞추면 된다. 이렇게 계속 가정과 가정 사이의 귀납적 증명이 반복된다.
  * 위의 과정을 보면 함수의 관계가 그대로 나타난다. $$5^4$$은 $$5^3$$가 5를 3번 곱한 값이 맞다는 걸 증명하기를 기다리고 있다. $$5^3$$은 $$5^2$$가 5를 2번 곱한 값이 맞다는 걸 증명하기를 기다리고 있다. $$5^2$$은 $$5^1$$가 5를 1번 곱한 값이 맞다는 걸 증명하기를 기다리고 있다. $$5^1$$은 $$5^0$$가 5를 0번 곱한 값이 맞다는 걸 증명하기를 기다리고 있다. 그런데 여기서 5를 0번 곱한 값은 수학적으로 1이라고 정의가 되어있다. 이것은 틀린 것이 아니라 맞는 정의이다. 따라서 거꾸로 올라가면서 기다리고 있는 모든 함수들에게 기다리고 있는 정의가 모두 맞다는 것을 알려주면서 결국 $$5^4$$가 5를 4번 곱한다는 것이 참임을 증명한다.
* 왜 귀납적 계산법이 제대로 된 값을 반환하는가?
  1. 수 많은 가정을 하다가
  2. 맨 끝에는 정확한 값이 있기 때문이다.



### 재귀함수가 의미있는 예제 ver.2

~~~c++
//getFactorial(n) : n!을 반환하는 함수
int getFactorial(int n){
    if(n == 0)
        return 1;
    else
        return n * getFactorial(n-1);
}

int main(){
    int n;
    scanf("%d", &n);
    prinf("%d\n", getFactorial(n));
}
~~~

getFactorial(n)이 n!을 반환한다는 것을 수학적으로 증명해야 모든 수에 대해 위의 재귀 함수에 성립한다고 볼 수 있다. 이것을 수학적으로 증명하는 방법이 있는데, 바로 '수학적 귀납법'이다.



## 수학적 귀납법을 통한 재귀함수의 정확성 증명

### 수학적 귀납법

* 명제(참/거짓을 판단할 수 있는 문장) P(n)이 모든 자연수 n에 대하여 성립함을 보이는 하나의 방법
* 증명 순서
  1. P(1)이 참임을 보인다.
  2. P(k)가 성립한다고 가정한 후, P(k+1)이 성립함을 보인다.
  3. 따라서 모든 자연수 n에 대하여 P(n)이 성립한다.



### 수학적 귀납법의 예 

* 명제 : 모든 자연수 n에 대하여 다음이 성립함을 보여라. 

* $$1+2+3+\cdot\cdot\cdot+n=\frac{n(n+1)}{2}$$ 

* 즉 P(n)은 위의 식이 성립하면 true, 아니면 false가 되는 것

* 증명 절차에 따른 증명

  1. P(1)이 성립함을 보인다. 
     1. 왼쪽도 1, 오른쪽도 1이므로 성립

  2. P(k)가 성립한다고 가정한 후, P(k+1)이 성립함을 보인다.
     1. $$1+2+3+\cdot\cdot\cdot+k=\frac{k(k+1)}{2}$$가 성립할 때, $$1+2+3+\cdot\cdot\cdot+(k+1)=\frac{(k+1)(k+2)}{2}$$ 가 맞는가?
     2. P(k)의 양 변에 k+1을 더하면 $$1+2+3+\cdot\cdot\cdot+(k+1)=\frac{k(k+1)}{2}+(k+1)$$이 된다. 이것이 P(k+1)과 같으면 된다.
     3. 왼쪽은 자연스럽게 같은 꼴이 만들어졌다. 그럼 우리의 질문은 $$\frac{k(k+1)}{2}+(k+1)$$ 도 $$\frac{k(k+1)}{2}$$꼴이 만들어지냐이다.
     4. 우변을 정리하면 $$\frac{k^2+k+(2k+2)}{2}$$가 되고, 다시 $$\frac{k^2+3k+2}{2}$$가 되고, 인수분해를 하면 결국 $$\frac{(k+1)(k+2)}{2}$$이 되어서 우리가 원하는 꼴이 만들어진다.  
  3. 이렇게 도미노 처럼 2부터 계속 증명이 참임을 밝힐 수 있으므로, 모든 자연수 n에 대하여 성립한다는 것을 알 수 있다.



### 재귀함수가 의미있는 예제 ver.3

```c++
//getFactorial(n) : n!을 반환하는 함수
int getFactorial(int n){
    if(n == 0)
        return 1;
    else
        return n * getFactorial(n-1);
}

int main(){
    int n;
    scanf("%d", &n);
    prinf("%d\n", getFactorial(n));
}
```

다시 돌아와서 getFactorial(n)이 n!을 반환한다는 것을 수학적 귀납법으로 증명해본다.

1. 제일 처음인 0일 때 성립하는가?
   1. getFactorial(0) = 1이므로 참이다.
2. getFactorial(k)가 성립할 때 getFactorial(k+1)이 성립하는가? 즉, getFactorial(K)이 k!를 반환할 때, getFactorial(k+1)이 (k+1)!을 반환하는가? 같은 방식으로 조금 더 편하게 증명하기 위해 getFactorial(k-1)이 (k-1)!일 때, getFactorial(k)가 k!임을 증명해본다.
   1. getFactorial(k)일 때, getFactorial(k)은 k*getFactorial(k-1)이다.
   2. 그런데 이 때 우리는 수학적 귀납법에 의해 getFactorial(k-1)이 (k-1)!이 성립한다는 것을 이미 가정했으므로, 당연하게 getFactorial(k-1)에 k를 곱하면 k!이라는 것이 성립한다.
3. 따라서 모든 자연수 n에 대해 getFactorial(n)이 성립하므로 getFactorial(n)은 n!을 제대로 반환한다는 것을 수학적 귀납법으로 증명했다.



사실 getFactorial(n) 코드 자체가 증명의 과정이다. 즉, 재귀함수가 하는 일은 **귀납적으로 계산하는 방법**이고, 이 과정은 수학적 귀납법으로 증명할 수 있다. 이 때, getFactorial(n)이 n!을 반환하는지 모름에도 불구하고 getFactorial(n)이 n!을 반환한다고 정의하면 <u>getFactorial(n-1)이 (n-1)!을 반환한다고 가정할 수 있다는 것</u>이 굉장히 중요한 부분이다. 따라서 **우리는 getFactorial(n-1)이 (n-1)!을 반환한다고 치고 getFactorial(n)이 n!을 반환하게 만들기만 하면 되는 것**이다!!



## 재귀함수 디자인의 절차

재귀함수가 나오면 이 3가지 절차를 **!!!무조건!!!**따라야 한다.

1. **함수의 역할을 말로 정확하게 정의한다.**
   1. 수학적 귀납법에서는 증명해야될 명제가 무엇인지를 아는 것과 같다. 증명해야될 것이 무엇인지를 알아야 증명을 한다. 
   2. 마찬가지로 계산할 것이 무엇인지를 알아야 계산을 한다. 즉, 함수에 무엇을 넣으면 무엇이 나오는 지, 함수의 역할을 말로 명확하게 정의해야 한다.
2. **기저조건(Base condition = 제일 단순한 경우)에서 함수가 제대로 동작함을 보인다.**
3. **함수가 (작은 input에 대하여) 제대로 동작한다고 가정하고 함수를 완성한다.**
   1. 수학적 귀납법에서 k일 때 성립한다고 가정하고 k+1을 증명하는 것과 똑같다.