---
layout: post
title: 객체지향개념 - 1(OOP,Object Oriented Programming)
excerpt: "클래스, 객체, 변수와 메서드, 메서드 오버로딩, 생성자, 변수의 초기화"
categories: [java]
link:
comments: true
---

#객체지향프로그래밍(OOP)

### 참고도서 : 자바의 정석 (남궁성 저, 도우 출판)

객체 지향 개념은 JAVA에서 가장 중요한 개념이자, 현대 프로그래밍 언어를 이해하는 데에 있어서 가장 중요한 부분이라고 할 수 있다. 기존에 절차적 언어와는 어떠한 특성이 있는지 비교하여 이해하고, 객체 지향과 그에 따른 개념을 공부해본다.

<h1>객체지향언어</h1>

객체지향이론의 기본 개념은 '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'라는 것이다. 객체지향프로그래밍은 실제 사물의 속성과 기능을 분석한 다음, 이것들을 데이터(변수)와 함수(메서드)로 정의한다. 또한 이것들간의 상호작용을 구현하기 위해 사물(객체)들 사이에 관계를 맺어주어, 마치 실제 세계를 컴퓨터 속에 옮겨 놓는 것처럼 컴퓨터 안의 세계를 구현하는 프로그래밍 방법이다. 이렇게 구현한 가상 세계에서는 현실에서 할 수 없는 많은 것들을 시도해볼 수 있으며 많은 시간과 비용을 절약할 수 있다. 이러한 객체지향프로그래밍을 위해 만들어진 언어들은 기존의 절차적 언어들에 비해 몇 가지 장점을 가진다.

* 코드의 재사용성이 높다.
    * 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
* 코드의 관리가 용이하다.
    * 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
* 신뢰성이 높은 프로그래밍을 가능하게 한다.
    * 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

<h3>클래스와 객체</h3>

* 클래스 : 객체를 정의해놓은 것(객체를 생성하는데 사용)
* 객체(≒인스턴스) :
  * 일반 개념 : 실제로 존재하는 것. 사물 또는 개념 (객체마다 각각의 기능과 속성이 다름)
  * 프로그래밍 개념 : 클래스에 정의된 내용대로 메모리에 생성된 것. 일반 개념의 객체 개념을 프로그래밍에서 본 딴 것이므로 객체마다 각각의 변수(≒속성)와 메서드(≒기능)가 다르다.(클래스와 객체의 관계를 설명할 때, 클래스에 의하여 생성된 객체를 인스턴스라고 일컫는다.)
  * 인스턴스(instance) : 어떤 클래스로부터 만들어진 객체
  * 인스턴스화(instantiate) : 클래스로부터 객체를 만드는 과정
* 객체의 구성 요소
  * 속성(property) = <U>멤버변수(member variable)</U>
  * 기능(function) = <U>메서드(method)</U>
~~~java
class Tv{
  String color; // 변수1. 색깔
  boolean power; // 변수2. 전원상태
  int channel; // 변수3. 채널

  void power(){
    power = !power;
  }// 메서드 1. 전원 온오프
  void channelUp(){
    channel++;
  }// 메서드 2. 채널 위로 변경
  void channelDown(){
    channel--;
  }// 메서드 3. 채널 아래로 변경
}
~~~

<h3>인스턴스의 선언과 생성</h3>

~~~java
//기본 구조
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t; // Tv클래스 타입의 참조변수 t를 선언
t =  new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv 인스턴스의 주소를 T에 저장

* 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.
~~~

<h3>객체 배열</h3>

같은 종류인 많은 수의 객체를 다룰 때 배열로 다루면 편리한데, 이를 '객체 배열'이라고 한다. 객체 배열은 배열 안에 객체가 저장되는 것이 아니고, 객체의 주소가 저장된다. 즉, 참조변수들을 하나로 묶은 참조변수 배열이라고 생각하면 된다.

~~~java
Tv tv1, tv2, tv3; -> Tv[] tvArr = new Tv[3];
~~~

<h1>변수와 메서드</h1>

<h3>변수</h3>

<h4>변수의 종류와 정의 : 변수가 선언된 위치에 따라 분류한다.</h4>

  * 클래스 변수(멤버 변수 - static) : 클래스 안의 모든 인스턴스가 공통으로 공유하는 변수.
  * 인스턴스 변수(멤버 변수 - non-static) : 클래스의 인스턴스를 생성할 때 만들어지는 변수. 따라서 인스턴스 변수의 값을 읽거나 저장하려면 먼저 인스턴스를 생성해야 한다. 인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다. 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우 인스턴스 변수로 선언한다. (즉 위의 Variables라는 클래스의 인스턴스 변수 iv는 Variables의 인스턴스 마다 초기화하여 다른 값을 가질 수 있다. 클래스 변수도 참조 변수를 통해 접근하여 초기화가 가능하다. 하지만 참조 변수들 모두가 클래스 변수가 저장되어 있는 저장 공간을 참조하는 것이므로 값을 초기화하면 이 저장 공간이 초기화되고, 새 인스턴스를 생성해도 초기화 된 클래스 변수의 값이 그대로 유지된다. 따라서 클래스 변수의 값이 변화해도 항상 공통된 값을 가진다는 속성에는 변화가 없다.)
  * 지역 변수 : 메서드 내에 선언되어 메서드 내에서만 사용가능하고, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.

![Smithsonian Image](http://cfile202.uf.daum.net/image/161A9A445029A155102D08)<br />
![Smithsonian Image](http://cfile221.uf.daum.net/image/120EC1365029A1622CF413)<br />

<h3>메서드</h3>

<h4>메서드 : 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것.</h4>

~~~java
//메서드의 선언 구조
반환 타입 메서드 이름(타입 변수명, 타입 변수명, ... /* 매개변수는 타입 생략 불가.*/) // 선언부
{
  메서드 내용 // 구현부
}

//메서드 선언의 예
int add(int a, int b)
{
  int result = a + b;
  return result; // 메서드는 단일한 결과 값만 반환한다. 반환 타입이 void가 아닌 이상 무조건 한 개 이상의 return문이 있어야 한다. return문의 타입은 반환 타입과 일치해야 한다.
}

//메서드 호출 방법
메서드 이름(값1, 값2, ...)
print99dalAll(); // void print99dalAll(void)를 호출
int result = add(3,5); // int add(int x, int y)를 호출하고, 결과를 result에 저장

* 위의 값1, 값2들을 인자라고 하고, int x, int y들을 매개변수라고 한다. 인자는 메서드가 호출되면서 매개변수에 대입되므로, 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다. 인자와 매개변수의 차이를 잘 알아두자.

* 매개변수의 유효성 검사 : 매개변수의 값이 적절한지 확인하는 것. 타입만 맞으면 어떤 값도 매개변수를 통해 넘어 올 수 있으므로 가능한 모든 경우의 수에 대해 고민하고 그에 대비한 코드를 작성해야한다.

* 기본형 매개변수 : 타입이 기본형인 매개변수. 단순히 저장된 값만을 얻으므로 변수의 값을 읽기만 할 수 있다.
* 참조형 매개변수 : 타입이 기본형이 아닌 매개변수. 저장된 곳의 주소를 얻으므로 변수의 값을 읽고 변경할 수 있다.

~~~

<h4>메서드의 종류</h4>

  * 클래스 메서드(static이 붙어있는 메서드) : 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드. 객체를 생성하지 않고 클래스이름.메서드이름(매개변수)으로 호출 가능. 그러나 클래스 변수가 호출되었을 때 인스턴스가 생성되어있지 않았을 수도 있으므로 클래스 변수는 인스턴스 메서드를 호출하는 것을 금지해 놓았다.
  * 인스턴스 메서드(static이 없는 메서드) : 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드. 객체를 생성해야만 호출 가능.

<h1>오버로딩</h1>

<h4>오버로딩 : 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것. 자바에서는 한 클래스 내에 이미 사용하는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있다.</h4>

<h4>오버로딩의 조건</h4>

  1. 메서드 이름이 같아야 한다.
  2. 매개변수의 개수 또는 타입이 달라야 한다.

<h4>오버로딩의 장점</h4>

  1. 여러 메서드들이 기능에 따라 같은 이름으로 정의될 수 있다.
  2. 메서드의 이름 절약이 가능하다.

>가변인자 : 기존에는 메서드의 매개변수 개수가 고정이었으나, JDK1.5부터 동적으로 지정이 가능해졌으며 이 기능을 '가변인자(variable arguments)'라고 한다.

~~~java
  public PrintStream printf(String format, Object.../*개수가 정해져 있지 않다.*/ args){...}
  //가변인자 외에도 매개변수가 더 있다면 가변인자를 매개변수 중에서 제일 마지막에 선언해야 한다. 그렇지 않으면 컴파일러가 가변인자인지 아닌지를 구분할 수 없으므로 컴파일 에러 발생.
~~~

<h1>생성자</h1>

<h4>생성자: 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'</h4>

<h4>생성자의 조건</h4>

  1. 생성자의 이름은 클래스의 이름과 같아야 한다.
  2. 생성자는 리턴 값이 없다.

<h4>생성자의 특징</h4>

  * 생성자도 오버로딩이 가능하므로 하나의 클래스에 여러개의 생성자가 존재할 수 있다.
  * 생성자가 인스턴스를 생성하는 것이 아니라 new 연산자가 인스턴스를 생성하는 것이다. 생성자는 몇 가지 특징을 제외하면 메서드와 다르지 않다.
  * 모든 클래스에는 하나 이상의 생성자가 있어야 한다. (클래스 내에 정의된 생성자가 하나도 없다면 컴파일러가 '클래스이름(){}'과 같은 형식의 기본 생성자를 자동으로 생성한다. 기본 생성자가 아닌 다른 생성자가 하나라도 있다면 기본 생성자는 자동으로 추가되지 않는다.)
~~~java
//생성자의 기본 구조
클래스이름(타입 변수명, 타입 변수명, ...){
  인스턴스 생성 시 수행될 코드,
  주로 인스턴스 변수의 초기화 코드를 적는다.
}

//생성자 오버로딩의 예
class Card{
  Card(){ //매개변수가 없는 생성자.
    ...
  }

  Card(String k, int num){ //매개변수가 있는 생성자.
    ...
  }
}

//인스턴스 생성시 수행 단계
Card c = new Card();
1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스 생성.
2. 생성자 Card()가 호출되어 수행
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장.
~~~

<h4>생성자 간의 호출 - this(), this</h4>

생성자 간 호출 시 만족해야하는 조건
  1. 생성자의 이름으로 클래스이름 대신 this를 사용.
  2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출 가능.

~~~java
1) 다른 생성자 호출 전
Car(){
  color = "white";
  gearType = "auto";
  door = 4;

2) Car(string a, String b, int c)호출 시
Car(){
  this("white", "auto", 4);
}
~~~

this: 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
this(), this(매개변수):

생성자를 이용한 인스턴스의 복사 : 현재 사용하고 있는 인스턴스와 같은 상태를 갖는 인스턴스를 하나 더 만들고자할 때 생성자 이용. 두 인스턴스가 같은 상태를 갖는다는 것은 두 인스턴스의 모든 인스턴스 변수(상태)가 동일한 값을 갖고 있다는 것.

~~~java
Car(Car c){ // 매개변수로 넘겨진 참조변수가 가리키는 Car인스턴스의 인스턴스 변수 값들을 인스턴스 자신으로 복사.
  color = c.color;
  gearType = c.gearType;
  door = c.door;
}
~~~

<h4>인스턴스 생성 시 고려해야할 것</h4>

  1. 클래스 : 어떤 클래스의 인스턴스를 생성할 것인가?
  2. 생성자 : 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?
