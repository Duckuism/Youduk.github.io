---
layout: post
title: 객체지향개념 - 3(OOP, Object Oriented Programming)
excerpt: " 다형성, 추상클래스, 인터페이스, 내부클래스 "
categories: [java]
link:
comments: true
---

### 참고 자료 : 자바의 정석(남궁성 저, 도우출판)


![Smithsonian Image](/img/2017-08-23-1.png)

![Smithsonian Image](/img/2017-08-23-2.png)

<h1>다형성(polymorphism)</h1>

* 다형성 : 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다. 좀 더 구체적으로 말하면 조상 클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.

* 참조변수의 인스턴스 사용
* 형변환
* 다형성을 때문에 헷갈리는 실제 타입을 알아보기 위해 쓰는 instanceof 연산자
* 가장 가까운 공통조상 클래스의 참조변수 배열을 통해 여러가지 객체를 묶어서 다루기


<h1>추상클래스(abstract class)</h1>

* 추상 클래스 : 완성되지 못한 채로 남겨진 추상 메서드를 포함하고 있는 클래스. 미완성된 클래스이기 때문에 인스턴스를 생성할 수 있다. 오직 상속을 통해서 자손 클래스에 의해서만 완성이 가능하다.

* 추상 메서드 : 메서드는 선언부와 구현부로 구현되어있는데, 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 메서드.

* 추상(抽象) : 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용.
* 추상화 : 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업 (추상 메서드의 선언부를 만드는 것)
* 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업 (추상 메서드의 구현부를 자손 요소에서 완성하는 것)

<h1>인터페이스(interface)</h1>

* 인터페이스 : 인터페이스는 일종의 추상 클래스이다. 하지만 일반 추상 클래스보다 추상화 정도가 더 높다. 즉, 공통적인 부분에서도 정말 필요한 부분만 공통적으로 뽑아낸 클래스이기 때문에 일반 추상 클래스와 달리 일반 메서드를 멤버변수로 가질 수 없다. 오직 추상 메서드와 상수만을 멤버로 가질 수 있다.

* 인터페이스의 다형성 : 인터페이스 역시 다형성을 이용하여 인터페이스의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있고, 인터페이스 타입으로 형변환이 가능하다.(자손에서 조상은 형변환 생략가능, 조상에서 자손은 형변환 필수 기재) 즉, 메서드의 매개 변수의 타입으로 인터페이스를 사용할 수 있다.

~~~java

//인터페이스 Fightable을 클래스 Fighter가 구현했을 때, 다음과 같이 Fighter 인스턴스를 Fightable타입의 참조변수로 참조 가능
Fightable f = (Fightable)new Fighter();
Fightable f = new Fighter(); //자손에서 조상으로의 형변환 표시 생략

//따라서 다음과 같이 메서드의 매개변수의 타입으로 사용될 수 있다. -> 메서드 attack 매개변수의 타입이 인터페이스 Fightable이라는 것은
//즉, Fightable이라는 인터페이스를 구현한 자손 클래스의 인스턴스가 메서드 attack의 매개변수로 들어와야한다는 뜻이다.
//인터페이스를 구현하는 많은 자손 클래스 중 어떤 자손 클래스가 올지 알 수는 없지만
//적어도 Fightable인터페이스를 구현하는 클래스들이므로 어떤 이름의 메서드들을 가지고 있고, 이 메서드들이 어떤 매개변수를 받아서,
//어떤 리턴 타입으로 결과를 반환할지는 예상이 가능하다.
//(Fightable인터페이스는 선언부는 정해져있지만 구현부는 정해져 있지 않은 추상 메서드를 가지고 있으므로 자손들은
//이 상태 그대로 물려받기때문이다. 즉 Fightable인터페이스를 구현하는 클래스들은 Fightable인터페이스가
//가진 추상 메서드의 선언부에 해당하는 리턴타입, 메서드 이름, 매개변수의 형식은 모두 똑같이 물려받은 상태에서 메서드를 구현해야 한다.)
void attack(Fightable f){
  //...
}
-> 즉, attack메서드의 매개변수로 Fightable인터페이스를 구현한 Fighter인스턴스를 넘겨줄 수 있다는 뜻이므로 attack(new Fighter())와 같이 쓸 수 있다.

Fightable method(){
  //Fighter f = new Fighter();
  //return f;
    return new Fighter(); //위의 두 문장을 한 문장으로 바꿈.
}

~~~

* 인터페이스의 장점
  * 개발시간을 단축시킬 수 있다. (메서드를 구현하는 팀 / 메서드를 호출하는 팀이 따로 작업 가능. 호출하는 쪽에서는 메서드 내용에 관계 없이 선언부만 알면 메서드 이름과 리턴 타입을 알 수 있기 때문에 사용하는 데에 문제가 없다. 이 동안에 메서드를 구현하는 팀은 인터페이스에 정해진 선언부에 맞춰서 원하는 기능을 가진 메서드 의 구현부를 만들면 된다.)
  * 표준화가 가능하다. (위와 같은 맥락으로, 인터페이스를 만들어서 작업을 하게되면 보다 일관적으로 프로그래밍이 가능.)
  * 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다. (서로 상속관계도 없고, 같은 조상클래스를 가지고 있지도 않은 아무 관계없는 클래스들을 하나의 인터페이스를 구현하게 함으로써 관계를 맺어줄 수 있다. 즉, 같은 인터페이스를 구현한다는 것은 공통적인 부분이 생긴다는 의미인데 이 점을 활용하여 묶어서 다룰 수 있다.)
  * 독립적인 프로그래밍이 가능하다. (메서드의 선언과 구현을 따로 하기 때문에 클래스의 선언과 구현을 분리시키는 것과 같다. 또한 클래스와 클래스간의 직접적인 관계(상속, 포함 관계)를 인터페이스를 통해 간접적인 관계로 변경하면, 한 클래스의 변경이 다른 클래스의 영향을 미치지 않는다. 즉, 클래스의 실제 구현을 독립적으로, 클래스와 클래스 간의 관계를 간접적으로 만듦으로써 독립성을 강화시킨다는 의미에서 독립적인 프로그래밍이 가능하다는 뜻이다.)

<h1>내부 클래스(inner class)</h1>

* 내부클래스 : 클래스 내에 선언된 클래스.

* 내부 클래스의 장점
  * 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
  * 코드의 복잡성을 줄일 수 있다.(캡슐화)
