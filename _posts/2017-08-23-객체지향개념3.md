---
layout: post
title: 객체지향개념 - 3(OOP, Object Oriented Programming)
excerpt: " 다형성, 추상클래스, 인터페이스, 내부클래스 "
categories: [java]
link:
comments: true
---

### 참고 자료 : 자바의 정석(남궁성 저, 도우출판)


![Smithsonian Image](/img/2017-08-23-1.png)

![Smithsonian Image](/img/2017-08-23-2.png)

<h1>다형성(polymorphism)</h1>

* 다형성 : 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다. 좀 더 구체적으로 말하면 조상 클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.

* 참조변수의 인스턴스 사용
* 형변환
* 다형성을 때문에 헷갈리는 실제 타입을 알아보기 위해 쓰는 instanceof 연산자
* 가장 가까운 공통조상 클래스의 참조변수 배열을 통해 여러가지 객체를 묶어서 다루기


<h1>추상클래스(abstract class)</h1>

* 추상 클래스 : 완성되지 못한 채로 남겨진 추상 메서드를 포함하고 있는 클래스. 미완성된 클래스이기 때문에 인스턴스를 생성할 수 있다. 오직 상속을 통해서 자손 클래스에 의해서만 완성이 가능하다.

* 추상 메서드 : 메서드는 선언부와 구현부로 구현되어있는데, 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 메서드.

* 추상(抽象) : 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용.
* 추상화 : 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업 (추상 메서드의 선언부를 만드는 것)
* 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업 (추상 메서드의 구현부를 자손 요소에서 완성하는 것)

<h1>인터페이스(interface)</h1>

* 인터페이스 : 인터페이스는 일종의 추상 클래스이다. 하지만 일반 추상 클래스보다 추상화 정도가 더 높다. 즉, 공통적인 부분에서도 정말 필요한 부분만 공통적으로 뽑아낸 클래스이기 때문에 일반 추상 클래스와 달리 일반 메서드를 멤버변수로 가질 수 없다. 오직 추상 메서드와 상수만을 멤버로 가질 수 있다.

* 인터페이스의 다형성 : 인터페이스 역시 다형성을 이용하여 인터페이스의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있고, 인터페이스 타입으로 형변환이 가능하다.(자손에서 조상은 형변환 생략가능, 조상에서 자손은 형변환 필수 기재) 즉, 메서드의 매개 변수의 타입으로 인터페이스를 사용할 수 있다.

~~~java

//인터페이스 Fightable을 클래스 Fighter가 구현했을 때, 다음과 같이 Fighter 인스턴스를 Fightable타입의 참조변수로 참조 가능
Fightable f = (Fightable)new Fighter();
Fightable f = new Fighter(); //자손에서 조상으로의 형변환 표시 생략

//따라서 다음과 같이 메서드의 매개변수의 타입으로 사용될 수 있다. -> 메서드 attack 매개변수의 타입이 인터페이스 Fightable이라는 것은
//즉, Fightable이라는 인터페이스를 구현한 자손 클래스의 인스턴스가 메서드 attack의 매개변수로 들어와야한다는 뜻이다.
//인터페이스를 구현하는 많은 자손 클래스 중 어떤 자손 클래스가 올지 알 수는 없지만
//적어도 Fightable인터페이스를 구현하는 클래스들이므로 어떤 이름의 메서드들을 가지고 있고, 이 메서드들이 어떤 매개변수를 받아서,
//어떤 리턴 타입으로 결과를 반환할지는 예상이 가능하다.
//(Fightable인터페이스는 선언부는 정해져있지만 구현부는 정해져 있지 않은 추상 메서드를 가지고 있으므로 자손들은
//이 상태 그대로 물려받기때문이다. 즉 Fightable인터페이스를 구현하는 클래스들은 Fightable인터페이스가
//가진 추상 메서드의 선언부에 해당하는 리턴타입, 메서드 이름, 매개변수의 형식은 모두 똑같이 물려받은 상태에서 메서드를 구현해야 한다.)
void attack(Fightable f){
  //...
}
-> 즉, attack메서드의 매개변수로 Fightable인터페이스를 구현한 Fighter인스턴스를 넘겨줄 수 있다는 뜻이므로 attack(new Fighter())와 같이 쓸 수 있다.

Fightable method(){
  //Fighter f = new Fighter();
  //return f;
    return new Fighter(); //위의 두 문장을 한 문장으로 바꿈.
}

~~~

* 인터페이스의 장점
  * 개발시간을 단축시킬 수 있다. (메서드를 구현하는 팀 / 메서드를 호출하는 팀이 따로 작업 가능. 호출하는 쪽에서는 메서드 내용에 관계 없이 선언부만 알면 메서드 이름과 리턴 타입을 알 수 있기 때문에 사용하는 데에 문제가 없다. 이 동안에 메서드를 구현하는 팀은 인터페이스에 정해진 선언부에 맞춰서 원하는 기능을 가진 메서드 의 구현부를 만들면 된다.)
  * 표준화가 가능하다. (위와 같은 맥락으로, 인터페이스를 만들어서 작업을 하게되면 보다 일관적으로 프로그래밍이 가능.)
  * 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다. (서로 상속관계도 없고, 같은 조상클래스를 가지고 있지도 않은 아무 관계없는 클래스들을 하나의 인터페이스를 구현하게 함으로써 관계를 맺어줄 수 있다. 즉, 같은 인터페이스를 구현한다는 것은 공통적인 부분이 생긴다는 의미인데 이 점을 활용하여 묶어서 다룰 수 있다.)
  * 독립적인 프로그래밍이 가능하다. (메서드의 선언과 구현을 따로 하기 때문에 클래스의 선언과 구현을 분리시키는 것과 같다. 또한 클래스와 클래스간의 직접적인 관계(선언과 구현이 분리되지 않은 관계)를 인터페이스를 통해 간접적인 관계로 변경하면, 한 클래스의 변경이 다른 클래스의 영향을 미치지 않는다. 즉, 클래스의 실제 구현을 독립적으로, 클래스와 클래스 간의 관계를 간접적으로 만듦으로써 독립성을 강화시킨다는 의미에서 독립적인 프로그래밍이 가능하다는 뜻이다.)

<h1>내부 클래스(inner class)</h1>

* 내부클래스 : 클래스 내에 선언된 클래스.

* 내부 클래스의 장점
  * 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
  * 코드의 복잡성을 줄일 수 있다.(캡슐화)


내부 클래스의 종류는 변수의 선언 위치에 따른 변수의 종류(인스턴스 변수, 클래스 변수, 지역 변수)에 익명 클래스만 추가한 것이다. 익명 클래스를 지외한 나머지 내부 클래스들은 기본적으로 멤버 변수와 같은 역할을 한다. 따라서 멤버 변수들에 적용되는 규칙이 내부 클래스에도 똑같이 적용된다.

내부 클래스의 특징 = 클래스의 특징(제어자 사용 가능) + 변수의 특징(클래스 변수와 인스턴스 변수 상호 호출 규칙, 접근 규칙 적용 / 다른 메서드에 지역 클래스 이름이 같게 선언될 수도 있음. 이 때는 컴파일러가 알아서 파일명레에 숫자를 매겨서 구별)

  |  <center>내부클래스의 종류</center> |  <center>특징</center>|
  |:--------|:--------|
  |**인스턴스 클래스<br />(instance class)** |외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다.|
  |**스태틱 클래스<br />(static class)** |외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언된다.|
  |**지역 클래스<br />(local class)** |외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.|
  |**익명 클래스<br /> (anonymous class)** |클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)|


~~~java
//외부 클래스와 내부 클래스
class A { //외부 클래스
  class B { //내부 클래스

  }
}

//내부 클래스 종류에 따른 선언 예시
class Outer{
  (private, protected / abstract, final / static은 선언 불가(인스턴스 변수 클래스 안에서 스태틱 변수를 선언할 수 없는 원리와 같음)) class InstanceInner{} // 인스턴스 내부 클래스
  (private, protected / abstract, final / static 선언 가능(스태틱 클래스 이므로 스태틱 변수 선언 가능)) static class StaticInner{} // 스태틱 내부 클래스

  void myMethod(){
    (private, protected / abstract, final / static은 선언 불가(인스턴스 변수 클래스 안에서 스태틱 변수를 선언할 수 없는 원리와 같음)) class LocalInner() // 메서드 내의 지역 내부 클래스
  }

(클래스 이므로 abstract, final같은 제어자를 사용 할 수 있으며 멤버 변수의 특징을 가지고 있으므로 private, protected와 같은 접근 제어자도 사용이 가능하다. static )

}

//내부 클래스의 클래스끼리 접근성과 외부 클래스 변수들에 대한 접근성. (이 부분이 내부 클래스의 가장 중요한 부분인 듯 하다. 조금 어려운 감이 있어 자바의 정석 예제를 그대로 치면서 이해해보았다.)

class InnerEx2{
  class InstanceInner {} // 클래스 InnerEx2안에 인스턴스 내부 클래스 InstanceInner 선언.
  static class StaticInner {} // 클래스 InnerEx2안에 스태틱 내부 클래스 StaticInner 선언.

  InstanceInner iv = new InstanceInner(); // InstanceInner클래스의 인스턴스를 생성한 후, 그 곳을 가리키는 주소 값을 iv에 저장한다. 즉 인스턴스 멤버 iv와 InstanceInner클래스의 인스턴스 객체 간에는 설 직접 접근이 간

  static StaticInner cv = new StaticInner();

  static void staticMethod(){
      //static멤버는 인스턴스멤버에 직접 접근할 수 없다.
      InstanceInner obj1 = new InstanceInner();
      StaticInner obj2 = new StaticInner();

      //굳이 접근하려면 아래와 같이 객체를 생성해야 한다.
      //인스턴스 클래스는 외부 클래스를 먼저 생성해야만 생성할 수 있다.

      InnerEx2 outer = new InnerEx2();
      InstanceInner ojb1 = outer.new InstanceInner();
  }

  void instanceMethod(){
    //인스턴스메서드에서는 인스턴스멤버와 static멤버 모두 접근 가능하다.
    InstanceInner obj1 = new InstatnceInner();
    StaticInner obj2 = new StaticInner();
    //메서드 내에 지역적으로 선언도니 내부 클래스는 외부에서 접근할 수 없다.
    LocalInner lv = new LocalInner();
  }

  void myMethod(){
    class LocalInner {}
    LocalInner lv = new LocalInner();
  }
}

~~~

인스턴스 내부 클래스
  1. 외부 클래스의 인스턴스 멤버(외부 클래스 안의 내부 클래스, 변수, 메서드)를 외부 클래스의 객체생성 없이 사용 가능.
  2. 스태틱 내부 클래스의 멤버를 객체 생성없이 사용 가능.

스태틱 내부 클래스
  1. 외부 클래스의 인스턴스 멤버(외부 클래스 안의 내부 클래스, 변수, 메서드)를 외부 클래스의 객체생성 없이 사용 불가.
  2. 인스턴스 내부 클래스의 멤버 객체 생성없이 사용 불가.

-> 인스턴스 멤버는 같은 클래스에 있는 인스턴스 멤버와 스태틱 멤버 모두 직접 호출이 가능하지만, static멤버는 인스턴스 멤버를 직접 호출할 수 없는 원리를 내부 클래스에 그대로 적용한다고 생각하면 이해가 쉽다. (스태틱 멤버는 클래스 로딩 때 모두 생성되지만 인스턴스 멤버는 해당 인스턴스가 생성 될 때 생성되므로 스태틱 멤버가 인스턴스 멤버를 호출 할 때 인스턴스 멤버가 들어있는 인스턴스가 생성되어있지 않았으면 사용할 수 없다. 따라서 java에서는 스태틱 멤버가 인스턴스 멤버를 호출하는 것을 금지해놓았다.)

~~~java
//내부 클래스에서 외부 클래스의 변수들에 대한 접근성을 보여주는 예제
class InnerEx3{
  private int outerIv = 0; //외부 클래스 InnerEx3에서 인스턴스 변수 선언 및 초기화.
  static int outerCv = 0; //외부 클래스 InnerEx3에서 스태틱 변수 선언 및 초기화.

  class InstanceInner{ // 인스턴스 내부 클래스
    int iiv = outerIv; //내부 인스턴스 클래스 InstanceInner에서 외부 클래스 InnerEx3의 인스턴스 변수 outerIv를 참조해서 대입.
    int iiv2 = outerCv; //내부 인스턴스 클래스 InstanceInner에서 외부 클래스 InnerEx3의 스태틱 변수 outerIv를 참조해서 대입.
  }

  static class StaticInner{ // 스태틱 내부 클래스
    int siv = outerIv; // 에러. 스태틱 내부 클래스 안에서는 외부 클래스의 인스턴스 멤버에 접근 불가.
    static int scv = outerCv; // 가능. 스태틱 내부 클래스 안에서 외부 클래스의 스태틱 멤버에 접근 가능.

  }

  void myMethod(){
    int Iv = 0; //외부 클래스의 멤버 메서드 myMethod() 안에 인스턴스 변수 Iv선언 후 0으로 초기화
    final int LV = 0; //외부 클래스의 멤버 메서드 myMethod() 안에 상수(final이 붙은 인스턴스 변수) Lv선언 후 0으로 초기화

    class LocalInner{
      int Iiv = outerIv; //외부 클래스의 멤버 메서드 myMethod() 안에 지역 내부 클래스 안에 인스턴스 변수 Iiv 선언 후, 외부 클래스의 인스턴스 변수 outerIv를 참조하여 초기화.
      int Iiv2 = outerCv; //외부 클래스의 멤버 메서드 myMethod() 안에 지역 내부 클래스 안에 인스턴스 변수 Iiv 선언 후, 외부 클래스의 스태틱 변수 outerCv를 참조하여 초기화.
      int Iiv3 = Iv; // 에러. final int Iiv3 = Iv;로 바꿔야 에러 아님. 상수로 지정되지 않은 변수는 참조 불가. jdk1.8부터는 final을 생략해도 컴파일러가 붙여주기 때문에 가능.
      int Iiv4 = LV; // 가능. (이미 메서드 myMethod()에서 상수로 선언한 변수 LV을 참조하므로.)
    }

  }
}

~~~


메서드 내 지역 내부 클래스
  1. 외부 클래스의 인스턴스 멤버와 static멤버 모두 사용 가능.
  2. 지역 클래스가 포함된 메서드에 정의된 지역변수도 사용 가능.(단, final이 붙은 변수만 사용 가능. 메서드가 수행을 마치고 지역변수가 소멸된 시점에도 지역 내부 클래스의 인스턴스가 소멸된 메서드의 지역변수를 참조하려는 경우가 발생할 수 있기 때문. jdk1.8부터는 final 붙이는 것을 생략해도 컴파일러가 알아서 붙여줌.)



##### 익명 클래스(anonymous class)

익명 클래스 : 이름 그대로 이름이 존재하지 않는 내부 클래스이다. 다른 내부 클래스들과 달리 이름이 없고 클래스의 선언과 생성을 동시에 하기 때문에 단 한번만 사용가능할 수 있으며, 오직 하나의 객체만을 생성할 수 있다. 이름이 없으므로 생성자도 가질 수 없다. 또한 조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에 하나의 클래스를 상속받는 동시에 다른 인터페이스를 구현하거나 동시에 두 개 이상의 인터페이스를 구성하는 것이 불가능하다. 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.

~~~java
//익명 클래스의 작명은 상속받는 클래스의 이름이나 구현하는 인터페이스의 이름으로만 할 수 있다.
new 상속 받는 조상클래스이름(){
   //멤버 선언
}
 혹은
new 구현하는 인터페이스 이름(){
  //추상 메서드 구현
}

//익명 클래스의 사용 예
class InnerEx6 {
  Object iv = new Object(){void method(){};} // 인스턴스 익명 클래스
  static Object cv = new Object(){void method(){};} // 스태틱 익명 클래스

  void myMethod(){
    Object lv = new Object(){ void method(){};} // 지역 익명 클래스
  }
}

~~~
