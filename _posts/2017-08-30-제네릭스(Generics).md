---
layout: post
title: 제네릭스(Generics)
excerpt: "형 변환의 지옥에서 탈출하자!"
categories: [java]
link:
---

### 지네릭스
###### 참고도서 : 자바의 정석(남궁성 저, 도우출판)

###1. 지네릭스란?

지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크(compile-time type check)를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다. 타입 안정성을 높인다는 것은 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄여준다는 뜻이다.

>간단히 얘기하면 다룰 객체의 타입을 미리 명시해줌으로써 번거로운 형변환을 줄여준다는 얘기다.

###2. 지네릭 클래스의 선언
~~~java

//CASE1. 지네릭스 사용 전
class Box{
  Object item;

  void setItem(Object item){this.item = item;}
  Object getItem(){return item;}
}

//CASE2. 지네릭스 사용 후
class Box<B>{
  T item;

  void setItem(T item){this.item = item;}
  T getItem(){return item;}
}

~~~

CASE2 BoX<T> '타입 변수(type variable)'라고 하며, 'Type'의 첫 글자에서 따온 것이다. 타입 변수는 T가 아닌 다른 것을 사용해도 된다. ArrayList<E>의 경우, 타입 변수 E는 'Element(요소)'의 첫 글자를 따서 사용했다. 타입 변수라 여러 개인 경우에는 Map<K,V>와 같이 콤마(,)를 구분자로 나열하면 된다. K는 Key(키)를 의미하고, V는 Value(값)을 의미한다. 무조건 'T'를 사용하기보다 가능하면, 이처럼 상황에 맞게 의미있는 문자를 선택해서 사용하는 것이 좋다. 이들은 기호의 종류만 다를 뿐 '임의의 참조형 타입'을 의미한다는 것은 모두 같다.

기존에는 다양한 종류의 타입을 다루는 메서드의 매개변수나 리턴타입으로 Object타입의 참조변수를 많이 사용했고, 그로 인해 형변환이 불가피했지만, 이젠 Object타입 대신 원하는 타입을 지정하기만 하면 되는 것이다.

그 다음 지네릭 클래스가 된 클래스의 객체를 생성할 때는 다음과 같이 참조변수와 생성자에 타입 T대신에 사용될 실제 타입을 지정해주어야 한다.

~~~java
Box<String> b = new Box<String>();  //타입 T 대신, 실제 타입을 지정
b.setItem(new Object());            //에러. String 이외의 타입은 지정불가
b.setItem("ABC");                   //OK. String타입이므로 가능
String item = (String) b.getItem(); //형변환이 필요없음
~~~

위의 코드에서 타입 T대신에 String타입을 지정해줬으므로, 지네릭 클래스 Box<T>는 다음과 같이 정의된 것과 같다.

~~~java
class Box<String>{
  String item;
  void setItem(Sting item){this.item = item;}
  String getItem(){return item;}
}
~~~

만일 Box클래스에 String만 담을 거라면, 타입 변수를 선언하지 않고 위와 같이 직접 타입을 적어주는 것도 가능하다. 단, Box<String>클래스는 String타입만 담을 수 있다. 반면에 Box<T>클래스는 어떤 타입이든 한 가지 타입을 정해서 담을 수 있다.

지네릭이 도입되기 이전의 코드와 호환을 위해, 지네릭 클래스인데도 예전의 방식으로 객체를 생성하는 것이 허용된다. 다만 지네릭 타입을 지정하지 않아서 안전하지 않다는 경고가 발생한다.

~~~java
Box b = new Box(); //OK. T는 Object로 간주된다. 하지만 타입 변수 T를 명시해주지 않았다.
b.setItem("ABC"); //경고. unchecked or unsafe operation
b.setItem(new Object()); //경고 unchecked or unsafe operation
~~~

~~~java
Box<Object> b = new Box<Object>(); //이번에는 타입 변수 T를 Object로 명시해주었다.
b.setItem("ABC"); //경고발생 안함
b.setItem(new Object()); //경고발생 안함
~~~

지네릭스가 도입되기 이전의 코드와 호환성을 유지하기 위해서 지네릭스를 사용하지 않은 코드를 허용하는 것일 뿐, 앞으로 지네릭 클래스를 사용할 때는 반드시 타입을 지정해서 지네릭스와 관련된 경고가 나오지 않도록 하자.

####지네릭스의 용어

~~~java
class Box<T> {}
~~~
~~~java
Box<T> : 지네릭 클래스. 'T의 Box' 또는 'T Box'라고 읽는다.
T      : 타입 변수 또는 타입 매개변수.(T는 타입 문자)
Box    : 원시 타입(raw type)
~~~
타입 문자 T는 지네릭 클래스 Box<T>의 타입 변수 또는 타입 매개변수라고 하는데, 메서드의 매개변수와 유사한 면이 있기 때문이다. 그래서 아래와 같이 타입 매개변수에 타입을 지정하는 것을 '지네릭 타입 호출'이라고 하고, 지정된 타입'String'을 '매개변수화된 타입(parameterized type)'이라고 한다. 매개변수화된 타입이라는 용어가 좀 길어서, 앞으로 이 용어 대신 '대입된 타입'이라는 용어를 사용할 것이다.

~~~java
    //대입된 타입
      Box<String> b = new Box<String>();
    //지네릭 타입 호출 //지네릭 타입 호출
~~~

예를 들어, Box<String>과 Box<Integer>는 지네릭 클래스 Box<T>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 이 둘이 별개의 클래스를 의미하는 것은 아니다. 이는 마치 매개변수의 값이 다른 메서드 호출, 즉 add(3,5)와 add(2,4)가 서로 다른 메서드를 호출하는 것이 아닌 것과 같다.

컴파일 후에 Box<String>과 Box<Integer>는 이들의 '원시 타입'인 Box로 바뀐다. 즉, 지네릭 타입이 제거된다. 이에 대해서는 '지네릭 타입의 제거'에서 자세히 설명한다.

####지네릭스의 제한
지네릭 클래스 Box의 객체를 생성할 때, 객체별로 다른 타입을 지정하는 것은 적절하다. 지네릭스는 이처럼 인스턴스별로 다르게 동작하도록 하려고 만든 기능이기 때문이다.

~~~java
Box<Apple> appleBox = new Box<Apple>();
Box<Grape> grapeBox = new Box<Grape>();
~~~

그러나 모든 객체에 동일하게 동작해야하는 static멤버에 타입 변수 T를 사용할 수 없다. T는 인스턴스변수로 간주되기 때문이다. 이미 알고 있는 것처럼 static멤버는 인스턴스변수를 참조할 수 없다.

~~~java
class Box<T>{
  static T item; // 에러
  static int compare(T t1, T t2){} // 에러
}
~~~

static 멤버는 타입 변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일한 것이어야 하기 때문이다. 즉, 'Box<Apple>.item'과 'Box<Grape>.item'이 다른 것이어서는 안된다는 뜻이다. 그리고 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다. 지네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만, 'new T[10]'과 같이 배열을 생성하는 것은 안된다는 뜻이다.

~~~java
class Box<T>{
    T[] itemArr;
    T[] toArray(){
        T[] tmpArr = new T[itemArr.length] // 에러. 지네릭 배열 생성 불가
        tmpArr;
    }
}
~~~

지네릭 배열을 생성할 수 없는 것은 new연산자 때문인데, 이 연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다. 그런데 위의 코드에 정의된 Box<T>클래스를 컴파일하는 시점에서는 T가 어떤 타입이 될지 전혀 알 수 없다. instanceof 연산자도 new 연산자와 같은 이유로 T를 피연산자로 사용할 수 없다. (타입에 따라 메모리 할당 용량이 달라지기 때문에 타입이 확정되지 않으면 배열이 저장될 공간 자체를 만들 수가 없는 것.) 꼭 지네릭 배열을 생성해야할 필요가 있을 때는, new연산자대신 'Reflection API'의 newInstance()와 같이 동적으로 객체를 생성하는 메서드로 배열을 생성하거나, Object배열을 생성해서 복사한 다음에 'T[]'로 형변환하는 방법 등을 사용한다.
