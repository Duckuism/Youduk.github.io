---
layout: post
title: 제네릭스(Generics)
excerpt: "형 변환의 지옥에서 탈출하자!"
categories: [java]
link:
---

### 지네릭스
###### 참고도서 : 자바의 정석(남궁성 저, 도우출판)

* 흐름을 읽기 위한 단원 목차 훑기
  1. 지네릭스란?
  2. 지네릭 클래스의 선언
  3. 지네릭 클래스의 객체 생성과 사용
  4. 제한된 지네릭 클래스
  5. 와일드 카드
  6. 지네릭 메서드
  7. 지네릭 타입의 형변환
  8. 지네릭 타입의 제거

<!-- ###1. 지네릭스란?

지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크(compile-time type check)를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다. 타입 안정성을 높인다는 것은 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄여준다는 뜻이다.

>간단히 얘기하면 다룰 객체의 타입을 미리 명시해줌으로써 번거로운 형변환을 줄여준다는 얘기다.

###2. 지네릭 클래스의 선언
~~~java

//CASE1. 지네릭스 사용 전
class Box{
  Object item;

  void setItem(Object item){this.item = item;}
  Object getItem(){return item;}
}

//CASE2. 지네릭스 사용 후
class Box<B>{
  T item;

  void setItem(T item){this.item = item;}
  T getItem(){return item;}
}

~~~

CASE2 BoX<T> '타입 변수(type variable)'라고 하며, 'Type'의 첫 글자에서 따온 것이다. 타입 변수는 T가 아닌 다른 것을 사용해도 된다. ArrayList<E>의 경우, 타입 변수 E는 'Element(요소)'의 첫 글자를 따서 사용했다. 타입 변수라 여러 개인 경우에는 Map<K,V>와 같이 콤마(,)를 구분자로 나열하면 된다. K는 Key(키)를 의미하고, V는 Value(값)을 의미한다. 무조건 'T'를 사용하기보다 가능하면, 이처럼 상황에 맞게 의미있는 문자를 선택해서 사용하는 것이 좋다. 이들은 기호의 종류만 다를 뿐 '임의의 참조형 타입'을 의미한다는 것은 모두 같다.

기존에는 다양한 종류의 타입을 다루는 메서드의 매개변수나 리턴타입으로 Object타입의 참조변수를 많이 사용했고, 그로 인해 형변환이 불가피했지만, 이젠 Object타입 대신 원하는 타입을 지정하기만 하면 되는 것이다.

그 다음 지네릭 클래스가 된 클래스의 객체를 생성할 때는 다음과 같이 참조변수와 생성자에 타입 T대신에 사용될 실제 타입을 지정해주어야 한다.

~~~java
Box<String> b = new Box<String>();  //타입 T 대신, 실제 타입을 지정
b.setItem(new Object());            //에러. String 이외의 타입은 지정불가
b.setItem("ABC");                   //OK. String타입이므로 가능
String item = (String) b.getItem(); //형변환이 필요없음
~~~

위의 코드에서 타입 T대신에 String타입을 지정해줬으므로, 지네릭 클래스 Box<T>는 다음과 같이 정의된 것과 같다.

~~~java
class Box<String>{
  String item;
  void setItem(Sting item){this.item = item;}
  String getItem(){return item;}
}
~~~

만일 Box클래스에 String만 담을 거라면, 타입 변수를 선언하지 않고 위와 같이 직접 타입을 적어주는 것도 가능하다. 단, Box<String>클래스는 String타입만 담을 수 있다. 반면에 Box<T>클래스는 어떤 타입이든 한 가지 타입을 정해서 담을 수 있다.

지네릭이 도입되기 이전의 코드와 호환을 위해, 지네릭 클래스인데도 예전의 방식으로 객체를 생성하는 것이 허용된다. 다만 지네릭 타입을 지정하지 않아서 안전하지 않다는 경고가 발생한다.

~~~java
Box b = new Box(); //OK. T는 Object로 간주된다. 하지만 타입 변수 T를 명시해주지 않았다.
b.setItem("ABC"); //경고. unchecked or unsafe operation
b.setItem(new Object()); //경고 unchecked or unsafe operation
~~~

~~~java
Box<Object> b = new Box<Object>(); //이번에는 타입 변수 T를 Object로 명시해주었다.
b.setItem("ABC"); //경고발생 안함
b.setItem(new Object()); //경고발생 안함
~~~

지네릭스가 도입되기 이전의 코드와 호환성을 유지하기 위해서 지네릭스를 사용하지 않은 코드를 허용하는 것일 뿐, 앞으로 지네릭 클래스를 사용할 때는 반드시 타입을 지정해서 지네릭스와 관련된 경고가 나오지 않도록 하자.

####지네릭스의 용어

~~~java
class Box<T> {}
~~~
~~~java
Box<T> : 지네릭 클래스. 'T의 Box' 또는 'T Box'라고 읽는다.
T      : 타입 변수 또는 타입 매개변수.(T는 타입 문자)
Box    : 원시 타입(raw type)
~~~
타입 문자 T는 지네릭 클래스 Box<T>의 타입 변수 또는 타입 매개변수라고 하는데, 메서드의 매개변수와 유사한 면이 있기 때문이다. 그래서 아래와 같이 타입 매개변수에 타입을 지정하는 것을 '지네릭 타입 호출'이라고 하고, 지정된 타입'String'을 '매개변수화된 타입(parameterized type)'이라고 한다. 매개변수화된 타입이라는 용어가 좀 길어서, 앞으로 이 용어 대신 '대입된 타입'이라는 용어를 사용할 것이다.

~~~java
    //대입된 타입
      Box<String> b = new Box<String>();
    //지네릭 타입 호출 //지네릭 타입 호출
~~~

예를 들어, Box<String>과 Box<Integer>는 지네릭 클래스 Box<T>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 이 둘이 별개의 클래스를 의미하는 것은 아니다. 이는 마치 매개변수의 값이 다른 메서드 호출, 즉 add(3,5)와 add(2,4)가 서로 다른 메서드를 호출하는 것이 아닌 것과 같다.

컴파일 후에 Box<String>과 Box<Integer>는 이들의 '원시 타입'인 Box로 바뀐다. 즉, 지네릭 타입이 제거된다. 이에 대해서는 '지네릭 타입의 제거'에서 자세히 설명한다.

####지네릭스의 제한
지네릭 클래스 Box의 객체를 생성할 때, 객체별로 다른 타입을 지정하는 것은 적절하다. 지네릭스는 이처럼 인스턴스별로 다르게 동작하도록 하려고 만든 기능이기 때문이다.

~~~java
Box<Apple> appleBox = new Box<Apple>();
Box<Grape> grapeBox = new Box<Grape>();
~~~

그러나 모든 객체에 동일하게 동작해야하는 static멤버에 타입 변수 T를 사용할 수 없다. T는 인스턴스변수로 간주되기 때문이다. 이미 알고 있는 것처럼 static멤버는 인스턴스변수를 참조할 수 없다.

~~~java
class Box<T>{
  static T item; // 에러
  static int compare(T t1, T t2){} // 에러
}
~~~

static 멤버는 타입 변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일한 것이어야 하기 때문이다. 즉, 'Box<Apple>.item'과 'Box<Grape>.item'이 다른 것이어서는 안된다는 뜻이다. 그리고 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다. 지네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만, 'new T[10]'과 같이 배열을 생성하는 것은 안된다는 뜻이다.

~~~java
class Box<T>{
    T[] itemArr;
    T[] toArray(){
        T[] tmpArr = new T[itemArr.length] // 에러. 지네릭 배열 생성 불가
        tmpArr;
    }
}
~~~

지네릭 배열을 생성할 수 없는 것은 new연산자 때문인데, 이 연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다. 그런데 위의 코드에 정의된 Box<T>클래스를 컴파일하는 시점에서는 T가 어떤 타입이 될지 전혀 알 수 없다. instanceof 연산자도 new 연산자와 같은 이유로 T를 피연산자로 사용할 수 없다. (타입에 따라 메모리 할당 용량이 달라지기 때문에 타입이 확정되지 않으면 배열이 저장될 공간 자체를 만들 수가 없는 것.) 꼭 지네릭 배열을 생성해야할 필요가 있을 때는, new연산자대신 'Reflection API'의 newInstance()와 같이 동적으로 객체를 생성하는 메서드로 배열을 생성하거나, Object배열을 생성해서 복사한 다음에 'T[]'로 형변환하는 방법 등을 사용한다.

###3. 지네릭 클래스의 객체 생성과 사용

지네릭 클래스 Box<T>가 다음과 같이 정의되어 있다고 가정하자. 이 Box<T>의 객체에는 한 가지 종류, 즉 T타입의 객체만 저장할 수 있다. 전과 달리 ArrayList를 이용해서 여러 객체를 저장할 수 있도록 하였다.

~~~java
class Box<T>{
  ArrayList<T> list = new ArrayList<T>();

  void add(T item)          {list.add(item);}
  T get(int i)              {return list.get(i);}
  ArrayList<T> getList()    {return list;}
  int size()                {return list.size();}
  public String toString()  {return list.toString();}
}
~~~

Box<T>의 객체를 생성할 때는 다음과 같이 한다. 참조변수와 생성자에 대입된 타입(매개변수화된 타입)이 일치해야 한다. 일치하지 않으면 에러가 발생한다.

~~~java
Box<Apple> apple box = new Box<Apple>(); //OK
Box<Apple> apple box = new Box<Grape>(); //에러
~~~

두 타입이 상속관계에 있어도 마찬가지이다. Apple이 Fruit의 자손이라고 가정하자.

~~~java
Box<Fruit> appleBox = new Box<Apple>(); //에러. 대입된 타입이 다르다.
                                        //상속 관계에서도 참조변수와 생성자에
                                        //대입된 타입이 일치해야한다.
~~~

단, 두 지네릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같은 것은 괜찮다. FruitBox는 Box의 자손이라고 가정하자.
~~~java
Box<Apple> appleBox = new FruitBox<Apple>(); // OK. 원시 타입 끼리는 다형성때문에 가능하다.
* 다형성 : 조상 객체의 참조 변수가 자손 인스턴스(객체)를 참조할 수 있는 것.
~~~

생성된 Box<T>의 객체에 'void add(T item)'으로 객체를 추가할 때, 대입된 타입과 다른 타입의 객체는 추가할 수 없다.
~~~java
Box<Apple> appleBox = new Box<Apple>;
appleBox.add(new Apple()); //OK
appleBox.add(new Grape()); //에러. Box<Apple>에는 Apple객체만 추가가능.
~~~

그러나 Apple이 Fruit의 자손이라고 가정한 상태에서 타입 T가 'Fruit'인 경우, 'void add(Fruit item)'가 되므로 Fruit의 자손들은 이 메서드의 매개변수가 될 수 있다.

~~~java
Box<Fruit> fruitBox = new Box<Fruit>;
appleBox.add(new Fruit()); //OK
appleBox.add(new Apple()); //OK. void add(Fruit item)
~~~

###4. 제한된 지네릭 클래스

다음 예제를 보자.

~~~java
FruitBox<Toy> fruitBox = new FruitBox<Toy>();
fruitBox.add(new Toy());
//OK. 과일상자에는 과일만 담아야하는데, 장난감을 담을 수 있는 상태다.
~~~

그렇다면 과일 상자에 과일만 담을 수 있게 제한할 수 없을까? 지네릭스를 이용하면 가능하다.
지네릭 타입에 'extends'를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.

~~~java
class FruitBox<T extends Fruit>{
  ArrayList<T> list = new ArrayList<T>();
}
~~~

여전히 한 종류의 타입만 담을 수 있는 건 변함이 없지만, Fruit클래스의 자손들만 담을 수 있다는 제한이 더 추가된 것이다.

~~~java
FruitBox<Apple> appleBox = new FruitBox<Apple>(); //OK
FruitBox<Toy> toyBox = new FruitBox<Toy>(); //에러. Toy는 Fruit의 자손이 아님.
//OK. 과일상자에는 과일만 담아야하는데, 장난감을 담을 수 있는 상태다.
~~~

게다가 add()의 매개변수의 타입 T도 Fruit와 그 자손 타입이 될 수 있으므로, 아래와 같이 여러 과일을 담을 수 있는 상자가 가능하게 된다.
~~~java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>;
fruitBox.add(new Apple()); // OK. Apple이 Fruit의 자손
fruitBox.add(new Grape()); // OK. Grape가 Fruit의 자손
~~~
>다형성에서 조상타입의 참조변수로 자손타입의 객체를 가리킬 수 있는 것처럼, 매개변수화된 타입의 자손 타입도 가능한 것이다. 타입 매개변수 T에 Object를 대입하면, 모든 종류의 객체를 저장할 수 있게 된다.

만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하다면, 이때도 'extends'를 사용한다. 'implements'를 사용하지 않는다는 점에 주의하자.

~~~java
interface Eatable{}
class FruitBox<T extends Eatable>{}
~~~

클래스 Fruit의 자손이면서 Eatable인터페이스도 구현해야한다면 아래와 같이 '&'기호로 연결한다.
~~~java
class FruitBox<T extends Fruit & Eatable>{}
~~~
이제 FruitBox에는 Fruit의 자손이면서 Eatable을 구현한 클래스만 타입 매개변수 T에 대입될 수 있다.

###5. 와일드카드

잘못하면 이해하기 어려운 부분이나, 자바의 정석에는 설명이 잘 되어 있어서 한 번에 이해했다.

매개변수에 과일박스를 대입하면 주스를 만들어서 반환하는 Juicer라는 클래스가 있고, 이 클래스에는 과일을 주스로 만들어서 반환하는 makeJuice()라는 static메서드가 다음과 같이 정의되어 있다고 가정하자.

~~~java
class Juicer{
    static Juice makeJuice(FruitBox<Fruit> box){ // 매개변수화된 타입을 Fruit로 지정.
        String tmp = "";
        for(Fruit f : box.getList()) tmp += f + "";
        return new Juice(tmp);
    }
}
~~~

Juicer 클래스는 지네릭 클래스가 아닌데다, 지네릭 클래스라고 해도 static메서드에는 타입 매개변수 T를 매개변수에 사용할 수 없으므로 아예 지네릭스를 적용하지 않던가, 위와 같이 타입 매개변수 대신, 특정 타입을 지정해줘야 한다.

~~~java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();

System.out.println(Juicer.makeJuice(fruitBox)); // OK. FruitBox<Fruit>
System.out.println(Juicer.makeJuice(appleBox)); // 에러. FruitBox<Apple>
~~~

이렇게 지네릭 타입을 'FruitBox<Fruit>'로 고정해 놓으면, 위의 코드에서 알 수 있듯이 'FruitBox<Apple>'타입의 객체는 makeJuice()의 매개변수가 될 수 없으므로, 다음과 같이 여러 가지 타입의 매개변수를 갖는 makeJuice()를 만들 수 밖에 없다.

~~~java
    static Juice makeJuice(FruitBox<Fruit> box){ //// 매개변수가 Fruit인 makeJuice()
        String tmp = "";
        for(Fruit f : box.getList()) tmp += f + "";
        return new Juice(tmp);
    }
~~~
~~~java
    static Juice makeJuice(FruitBox<Apple> box){ // 매개변수가 Apple인 makeJuice()
        String tmp = "";
        for(Fruit f : box.getList()) tmp += f + "";
        return new Juice(tmp);
    }
~~~

그러나 위와 같이 오버로딩하면, 컴파일 에러가 발생한다. **지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기 때문이다.** 지네릭 타입은 컴파일러가 컴파일할 때만 사용하고 제거해버린다. 그래서 위의 두 메서드는 오버로딩이 아니라 '메서드 중복 정의'이다.
이럴 때 사용하기 위해 고안된 것이 바로 '와일드 카드'이다. 와일드 카드는 기호 "?"로 표현하는데, 와일드 카드는 어떠한 타입도 될 수 있다.
"?"만으로는 Object타입과 다를 게 없으므로, 다음과 같이 'extends'와 'super'로 상한(upper bound)과 하한(lower bound)을 제한할 수 있다.
```
<? extends T> 와일드 카드의 상한 제한. T와 그 자손들만 가능
<? super T>   와일드 카드의 하한 제한. T와 그 조상들만 가능
<?>           제한 없음. 모든 타입이 가능. <? extends Object>와 동일
```

* 지네릭 클래스와 달리 와일드 카드에는 '&'을 사용할 수 없다. 즉, <?extends T&E>와 같이 할 수 없다.
와일드 카드를 사용해서 makeJuice()의 매개변수 타입을 FruitBox<Fruit>에서 FruitBox<? extends Fruit>으로 바꾸면 다음과 같이 된다.

~~~java
    static Juice makeJuice(FruitBox<? extends Fruit> box){ // 상한제한. 타입 변수 T와 그 자손들만 가능
        String tmp = "";
        for(Fruit f : box.getList()) tmp += f + "";
        return new Juice(tmp);
    }
~~~

이제 이 메서드의 매개변수로 FruitBox<Fruit>뿐만 아니라, FruitBox<Apple>와 FruitBox<Grape>도 가능하게 된다.(Apple과 Grape는 Fruit의 자손이므로!)
* 매개변수의 타입을 'FruitBox<? extends Object>'로 하면, 모든 종류의 FruitBox가 매개변수로 가능하다.

~~~java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();

System.out.println(Juicer.makeJuice(fruitBox)); // OK. FruitBox<Fruit>
System.out.println(Juicer.makeJuice(appleBox)); // OK. FruitBox<Apple>
~~~

매개변수의 타입을 FruitBox<? extends Object>로 하면, 모든 종류의 FruitBox가 이 메서드의 매개변수로 가능해진다. 대신, 전과 달리 box의 요소가 Fruit의 자손이라는 보장이 없으므로 아래의 for문에서 box에 저장된 요소를 Fruit타입의 참조변수로 받지 못한다.

~~~java
    static Juice makeJuice(FruitBox<? extends Fruit> box){ // 상한제한. 타입 변수 T와 그 자손들만 가능
        String tmp = "";
        for(**Fruit f** : box.getList()) tmp += f + ""; //**로 감싼 부분이 에러. Fruit이 아닐 수 있으므로.
        return new Juice(tmp);
    }
~~~

그러나 실제로 테스트를 해보면 문제없이 컴파일되는데 그 이유는 바로 지네릭 클래스 FruitBox를 제한했기 때문이다.

~~~java
class FruitBox<T extends Fruit> extends Box<T>{}
~~~

컴파일러는 위 문장으로부터 모든 FruitBox의 요소들이 Fruit의 자손이라는 것을 알고 있으므로 문제 삼지 않는 것이다.

###6. 지네릭 메서드

메서드의 선언부에 지네릭 타입이 선언된 메서드를 지네릭 메서드라 한다. 앞서 살펴본 것처럼, Collections.sort()가 바로 지네릭 메서드이며, 지네릭 타입의 선언 위치는 반환타입 바로 앞이다.

~~~java
static <T> void sort(List<T> list, Comparator<? super T>c)
~~~

지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 전혀 별개의 것이다. 같은 타입 문자 T를 사용해도 같은 것이 아니라는 것에 주의해야 한다.
* 지네릭 메서드는 지네릭 클래스가 아닌 클래스에도 정의될 수 있다.

~~~java
class FruitBox<T>{
   static <T> void sort(List<T> list, Comparator<? super T> c){ // 객체를 생성할 때 타입을 정하지 않은 상태이다.
  }
}
~~~

위의 코드에서 지네릭 클래스 FruitBox에 선언된 타입 매개변수 T와 지네릭 메서드 sort()에 선언된 타입 매개변수 T는 타입 문자만 같을 뿐 서로 다른 것이다. 그리고 sort()가 static 메서드라는 것에 주목하자. 앞서 설명한 것처럼, static멤버에는 타입 매개변수를 사용할 수 없지만(클래스에서 공통으로 쓰여야하는데 타입이 그때 그때 달라지면 안되므로), 이처럼 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능하다. (지네릭 타입은 메서드를 구별하는 시그니처 요소가 아니므로)

메서드에 선언된 지네릭 타입은 지역 변수를 선어한 것과 같다고 생가갛면 이해하기 쉬운데, 이 타입 매개변수는 메서드 내에서만 지역적으로 사용될 것이므로 메서드가 static이건 아니건 상관이 없다.
* 같은 이유로 내부 클래스에 선언된 타입 문자가 외부 클래스의 타입 문자와 같아도 구별될 수 있따.

앞서 나왔던 makeJuice()를 지네릭 메서드로 바꾸면 다음과 같다.

~~~java
    //전
    static Juice makeJuice(FruitBox<? extends Fruit> box){
        String tmp = "";
        for(Fruit f : box.getList()) tmp += f + "";
        return new Juice(tmp);
    }
    //후
    static <T extends Fruit> Juice makeJuice(FruitBox<T> box){
        String tmp = "";
        for(Fruit f : box.getList()) tmp += f + "";
        return new Juice(tmp);
    }
~~~

이제 이 메서드를 호출할 때는 아래와 같이 타입 변수에 타입을 대입해야 한다.
~~~java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();

System.out.println(Juicer.<Fruit>makeJuice(fruitBox));
System.out.println(Juicer.<Fruit>makeJuice(appleBox));
~~~
그러나 대부분의 경우 컴파일러가 타입을 추정할 수 있기 때문에 생략해도 된다. 위의 코드에서도 fruitBox와 appleBox의 선언부를 통해 대입된 타입을 컴파일러가 추정할 수 있다.
~~~java
System.out.println(Juicer.makeJuice(fruitBox)); // 대입된 타입 생략가능
System.out.println(Juicer.makeJuice(appleBox)); // 대입된 타입 생략 가능
~~~

한 가지 주의할 점은 지네릭 메서드를 호출할 때, 대입된 타입을 생략할 수 없는 경우에는 참조변수나 클래스 이름을 생략할 수 없다는 것이다.
~~~java
System.out.println(<Fruit>makeJuice(fruitBox)); //에러. 클래스 이름 생략 불가.
System.out.println(this.<Fruit>makeJuice(fruitBox)); // ok
System.out.println(Juicer.<Fruit>makeJuice(fruitBox)); //ok
~~~

같은 클래스 내에 있는 멤버들끼리는 참조변수나 클래스 이름, 즉 'this.'이나 '클래스이름.'을 생략하고 메서드 이름만으로 호출이 가능하지만, 대입된 타입이 있을 때는 반드시 써줘야 한다. 이것은 단지 기술적인 이유에 의한 규칙이므로 그냥 지키기만 하면 된다.

지네릭 메서드는 매개변수의 타입이 복잡할 때도 유용하다. 만일 아래와 같은 코드가 있다면 타입을 별도로 선언함으로써 코드를 간략히 할 수 있다.

~~~java
public static void printAll(ArrayList<? extends Products> list, ArrayList<? extends Products list2){
    for(Unit u : list){
        System.out.println(u);
    }
}

public static<T extends Products> void printAll(ArrayList<T> list, ArrayList<T> list2){
    for(Unit u : list){
        System.out.println(u);
    }
}

~~~

###6. 지네릭 타입의 형변환

지네릭 타입과 원시 타입(primitive type)간의 형변환은 가능하다. 하지만 경고가 발생한다.
~~~java
Box box = null;
Box<Object> objBox = null;

box = (Box)objBox;          // OK. 지네릭 타입 -> 원시 타입. 경고 발생
objBox = (Box<Object>)Box;  // OK. 원시 타입 -> 지네릭 타입. 경고 발생
~~~

그러면, 대입된 타입이 다른 지네릭 타입 간에는 형 변환이 가능할까?
~~~java
Box<Object> objBox = null;
Box<String> strBox = null;

objBox = (Box<Object>)strBox;  // 에러. Box<String> -> Box<Object>
strBox = (Box<Object>)objBox;  // 에러. Box<Object> -> Box<String>
~~~
불가능하다. 대입된 타입이 Object일지라도 말이다. 이 사실은 이미 배웠다. 아래의 문장이 안된다는 얘기는 Box<String>이 Box<Object>로 형변환될 수 없다는 사실을 간접적으로 알려주는 것이기 때문이다.

~~~java
//Box<Object>objBox = (Box<Object>)new Box<String>();
Box<Object>objBox = new Box<String>(); //에러. 형변환 불가능
~~~

그러면 다음의 문장은 어떨까? Box<String>이 Box<? extends Object>로 형변환 될까?
~~~java
Box<? extends Object>wBox = new Box<String>();
~~~
형변환이 된다. 그래서 전에 배운 makeJuice메서드의 매개변수에 다형성이 적용될 수 있었던 것이다.
~~~java
//매개변수로 FruitBox<Fruit>, FruitBox<Apple>, FruitBox<Grape>등이 가능
static Juice makeJuice(FruitBox<? extends Fruit> box){}

FruitBox<? extends Fruit> box = new FruitBox<Fruit>(); // OK
FruitBox<? extends Fruit> box = new FruitBox<Apple>(); // OK
FruitBox<? extends Fruit> box = new FruitBox<Grape>(); // OK
~~~

반대로의 형변환도 성립하지만, 확인되지 않은 형변환이라는 경고가 발생한다. 'FruitBox<? extends Fruit>'에 대입될 수 있는 타입이 여러 개인데다, FruitBox<Apple>을 제외한 다른 타입은 FruitBox<Apple>로 형변환될 수 없기 때문이다.

~~~java
FruitBox<? extends Fruit> box = null;
FruitBox<Apple> appleBox = (FruitBox<Apple>)box;
//OK. 미확인 타입으로 형변환 경고. box의 타입이 grape, apple, fruit 중에 어떤 것인지 알수 없어서 apple이 아닌 grape나 fruit면 FruitBox<Apple>로 형 변환이 안될 수도 있다.
~~~java

좀 더 실질적인 예를 살펴보자. 다음은 java.util.Optional 클래스의 실제 소스의 일부이다. 지금까지 배운 내용들을 떠올리며, 아래의 코드를 자세히 살펴보자.

~~~java
public final class Optional<T>{
  private static final Optional<?> EMPTY = new Optional<>();
  private final T value;
  ...
  public static<T> Optional<T> empty(){
    Optional<T> t = (Optional<T>)EMPTY;
    return t;
  }
}
~~~

static 상수 EMPTY에 비어있는 Optional 객체를 생성해서 저장했다가 empty()를 호출하면 EMPTY를 형변환해서 반환한다. 먼저 상수를 선언하는 문장을 단계별로 분석해보면 다음과 같다. 편의상 제어자는 생략한다.

~~~java
Optional<?> EMPTY = new Optional<>();
-> Optional<? extends Object> EMPTY = new Optional<>();
-> Optional<? extends Object> EMPTY = new Optional<Object>();
~~~

<?>는 <? extends Object>를 줄여 쓴 것이며, <>안에 생략된 타입은 '?'가 아니라 'Object'

~~~java
Optional<?> EMPTY = new Optional<?>(); //에러. 미확인 타입의 객체는 생성불가
Optional<?> EMPTY = new Optional<Object>(); //OK
Optional<?> EMPTY = new Optional<>(); //OK. 위의 문장과 동일

* 주의 : class Box<T extends fruit>의 경우 Box<?> b = new Box<>;는 Box<?> b = new Box<Fruit>;이다.
~~~

위의 문장에서 EMPTY의 타입을 Otional<Object>가 아닌 Optional<?>로 한 이유는 Optional<T>로 형변환이 가능하기 때문이다.

~~~java
Optional<?> wopt = new Optional<Object>();
Optional<Object> oopt = new Optional<Object>();

Optional<String> sopt = (Optional<String>) wopt; //OK. 형변환 가능
Optional<String> sopt = (Optional<String>) oopt; //에러. 형변환 불가
~~~

empty()의 반환 타입이 Optional<T>이므로 EMPTY를 Optional<T>로 형변환해야 하는데, 위의 코드에서 알 수 있는 것처럼 Optional<Object>는 Optional<T>로 형변환이 불가능하다.

~~~java
public static<T> Optional<T> empty(){
  Optional<T> t = (Optional<T>) EMPTY; //Optional<?> -> Optioanl<T>
  return t;
}
~~~
정리하면, Optional<Object>를 Optional<String>으로 직접 형변환하는 것은 불가능하지만, 와일드 카드가 포함된 지네릭 타입으로 형변환하면 가능하다. 대신 확인되지 않은 타입으로의 형변환이라는 경고가 발생한다.

~~~java
Optional<Object> -> Optional<T> //형변환 불가능
Optional<Object> -> Optional<T> -> Optional<T> // 형변환 가능. 경고 발생
~~~

마지막으로 하나만 덧붙이면, 다음과 같이 와일드 카드가 사용된 지네릭 타입끼리도 다음과 같은 경우에는 형변환이 가능하다.

FruitBox<? extends Object> objBox = null;
FruitBox<? extends String> strBox = null;

strBox = (FruitBox<? extends String>)objBox; // OK. 미확정 타입으로 형변환 경고
objBox = (FruitBox<? extends String>)strBox; // OK. 미확정 타입으로 형변환 경고

형변환이 가능하긴 하지만, 와일드 카드는 타입이 확정된 타입이 아니므로 컴파일러는 미확정 타입으로 형변환하는 것이라고 경고한다. -->



<수업 복습내용>
class ArrayList<T> {}
ArrayList<Apple> list = new ArrayList<Apple>();
ArrayList<Fruit> list = new ArrayList<Apple>();

List<Apple> list = new ArrayList<Appple>();

Apple a = (Apple)list.get(i); //제네릭스 사용 전
Apple a = list.get(i); // 제네릭스 사용후

ArrayList<? extends/super Fruit>list = new ArrayList<Apple>(); / new ArrayList<Grape>
