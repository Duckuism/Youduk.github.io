<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-121414052-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-121414052-1');
</script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linked List 관련 알고리즘</title>
  <meta name="description" content="Single linked list 구현하기, Single linked list에서 중복 데이터 제거하기, Single linked list 역으로 정렬하기,Single linked list에서 뒤에서 K번째 원소를 반환하는 함수 구현하기, Single linked list에서 회문...">

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/algorithm/2018/04/04/Linked-List-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7.html">
  <link rel="alternate" type="application/rss+xml" title="Ducku Salon" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>

<body>
  <script id="dsq-count-scr" src="//https-youduk-github-io.disqus.com/count.js" async></script>
  <div class="row">
    <div class="col s12 m12">
      <div class="table cover">
        
<div class="cover-card table-cell table-middle">
  
  <img src="http://localhost:4000/img/authorLogo.jpeg" alt="" class="avatar">
  
  <a href="http://localhost:4000/" class="author_name">Ducku Salon</a>
  <span class="author_job">portfolio &amp; Tech blog</span>
  <span class="author_bio mbm">Dreams are not dreamt, they are commplished.</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
                                                                           
    </ul>
  </nav>
  <script type="text/javascript">
  // based on https://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('rnejrl123456@gmail.com', 'Hello from website');</script>
      </li>
    
    
    <li><a href="https://facebook.com/originducku" class="social-link-item" target="_blank"><i class="fa fa-fw fa-facebook"></i></a></li>
    
    <li><a href="https://linkedin.com/in/youduk-han-2bbb94108" class="social-link-item" target="_blank"><i class="fa fa-fw fa-linkedin"></i></a></li>
    
    
    
    
    <li><a href="https://github.com/Youduk" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m12">
      <div class="post-listing">
        <div class="post-container">
<a class="btn" href="http://localhost:4000/">
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="Linked List 관련 알고리즘">Linked List 관련 알고리즘</h1>
    <span class="post-meta">
      <span class="post-date">
        4 APR 2018
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    19 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <h3 id="linked-list-이론-학습">Linked List 이론 학습</h3>

<p><img src="/img/2018-04-02-02.png" alt=""></p>

<p>제일 첫 번째 원소를 가리키는 head가 필요하고 head의 타입은 node타입이다. 제일 처음에는 null을 가리키고 있다.</p>

<p><img src="/img/2018-04-02-03.png" alt=""></p>

<p>위 그림은 새로운 원소를 추가했을 때의 그림이다. 
새로운 Node 클래스를 만들어주고, 이 Node클래스는 특정 데이터를 가지고 있고 다음 Node를 가리킬 수 있어야 한다. 원래는 generics으로 만들어도 되지만 예제에서는 간단하게 int 타입으로 만들었다. 다음 노드를 가리킬 수 있게 Node 타입의 next란 변수를 가지고 있다. 빨간색 화살표는 값이 변경되었기 때문이다. <code class="highlighter-rouge">node.next = head;</code>를 통해 next변수의 값이 head의 값으로 변경되었고, <code class="highlighter-rouge">head = node</code>를 통해 head의 값이 node의 값으로 변경되었다. 첫 번째 원소를 추가한 경우라서 그런 것이 아닐까? 원소를 하나 더 추가할 때는 다를까?</p>

<p><img src="/img/2018-04-02-04.png" alt=""></p>

<p>위 그림은 두 번째 새로운 원소를 추가했을 때의 그림이다.</p>

<p>녹색이 새로 추가된 노드고, 빨간 화살표는 값을 바꾸는 것이다. 코드는 동일하다.</p>

<p><img src="/img/2018-04-02-05.png" alt=""></p>

<p>위 그림은 Double Linked List의 그림이다.</p>

<p>더블링크드리스트의 경우는 앞, 뒤로 모두 갈 수 있어야 하므로 Node에 prev가 추가되어야 한다.</p>

<p>녹색창의 코드가 5줄인데, 그 이유는 값을 변화시키는 빨간색 화살표가 4줄이기 때문이다. 3줄이라고 착각하지 말 것. 즉 노드를 만드는 1줄과 값을 업데이트시키는 4줄이 있어야 하기 때문에 총 5줄의 코드가 필요한 것이다.</p>

<h4 id="linked-list-출제-경향">Linked List 출제 경향</h4>

<ul>
  <li>Double Linked List는 코딩 문제로 잘 출제되지 않는다. (복잡해서 시간이 오래걸리기 때문에)</li>
  <li>제한된 짧은 시간에 풀 수 잇는 문제가 출제된다.</li>
  <li>Single linked list로도 검증은 충분하다.</li>
  <li><u>Double linked list로는 쉽게 풀 수 있지만 Single linked list로는 풀기 까다로운 문제들이 자주 출제 된다.</u></li>
  <li>신입들을 위해 쉽게 낸다고하면 Single linked list의 기본 기능(삽입, 삭제)을 구현하는 문제가 출제되기도 하지만, <u>Single linked list가 있다고 가정하고 특정 기능의 함수를 구현하는 문제가 자주 출제 된다.</u>(Single linked list는 구현할 수 있다고 생각하고 여기의 head point가 주어지면 list의 순서를 바꿔보아라, list를 두 세개로 쪼개봐라, 특정 값을 도출해봐라 등)</li>
</ul>

<p>Linked리스트도 알고 있어야 하지만 작성하는 코드에서 가변 길이의 데이터를 생성하거나 처리할 때 자바에서 제공하는 컬렉션을 잘 알고 있어야 한다.</p>

<p><img src="/img/2018-04-02-06.png" alt=""></p>

<p>자주 쓰이는 클래스들이고, List인터페이스를 구현하고 있다. 같은 인터페이스를 구현했으므로 기본적인 함수들을 거의 비슷하다.</p>

<h4 id="1-single-linked-list-구현하기">1. Single linked list 구현하기</h4>

<ul>
  <li>
    <p>addToHead(n)</p>

    <ul>
      <li>리스트의 head에 노드를 추가</li>
      <li>node.data는 n으로 설정</li>
    </ul>
  </li>
  <li>
    <p>removeFirst()</p>

    <ul>
      <li>리스트의 첫 노드 제거</li>
      <li>제거할 것이 없으면 RuntimeException을 발생</li>
    </ul>
  </li>
  <li>
    <p>못 풀었다. 어째 20분안에 풀 수 있는게 하나도 없네 ㅡ_ㅡ 
아.. 나중에 보니까 class가 하나 더 있었다. 영향은 없는 부분이지만 앞으로 잘 확인해야겠다.</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td>
<td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.lang.RuntimeException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingleLinkedList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
        <span class="n">head</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">;</span>
    <span class="o">}</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">;</span>
    <span class="o">}</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"[ "</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="s">" "</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">str</span> <span class="o">+=</span> <span class="s">"]"</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>모범 답안</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td>
<td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.lang.RuntimeException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingleLinkedList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span> <span class="c1">// 새로운 노드 생성</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">n</span> <span class="c1">//node의 data는 n으로 설정</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="c1">//node의 next를 현재 head의 값으로 할당(node.next가 기존의 head가 가리키고 있던 맨 마지막 값을 가리킨다.)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span> <span class="c1">//head의 값을 새로생긴 node의 값으로 할당(head가 새로 생긴 노드를 가리킨다.)</span>
    <span class="o">}</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span> <span class="c1">//head가 null이면 아무것도 없는 것.</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Nothing to remove"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">//하나 밖에 없는 경우도 head가 null이 될테니 괜찮다.</span>
    <span class="o">}</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"[ "</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="s">" "</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">str</span> <span class="o">+=</span> <span class="s">"]"</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h4 id="2-single-linked-list에서-중복-데이터-제거하기">2. Single linked list에서 중복 데이터 제거하기</h4>

<ul>
  <li>
    <p>HastSet이라는 힌트가 있어서 어떻게 푸는지는 생각을 해봤는데, 코드로 못짜겠다..</p>
  </li>
  <li>
    <p>Set을 만들고 여기에 node데이터 값을 모두 넣었다가 빼면서 다시 link하는 방식으로 풀고 싶었다.</p>
  </li>
  <li>
    <p>모범답안</p>

    <p>123,12가 들어있으면 12가 중복이되어서 12를 제거하는 것. 정말 많이 출제된다.</p>

    <p>구현하는 방법은 여러가지가 있다. loop를 두 번 돌면서 중복 데이터를 제거할 수 있지만 비효율적이고 코드가 복잡해진다.</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td>
<td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"[ "</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="s">" "</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">str</span> <span class="o">+=</span> <span class="s">"]"</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
    <span class="o">}</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeDuplicates</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">HashaSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span><span class="c1">//node의 data가 Integer이므로</span>

        <span class="n">Node</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//더블링크드리스트는 검색을 해서 중복이면 바로 제거가 가능하지만 싱글링크드리스트는 중간에서 제거하기가 힘들다. 따라서 그 전의 노드에 대해 알고 있어야 한다.</span>
        <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="c1">//시작점을 지정한다.</span>
          
        <span class="k">while</span><span class="o">(</span><span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="c1">//중복체크는 우선 set에 데이터를 넣고 data가 다시 나오면 중복인 것. 123을 넣었는데 1이 또 나오면 중복인 원리.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">)){</span><span class="c1">//set에 현재 노드의 data가 존재한다면</span>
            	<span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">;</span><span class="c1">//이전 노드의 다음이 현재 노드가 아니라 현재의 다음 노드이므로 현재 노드는 링크가 해제된다.</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span><span class="c1">//set에 없는 노드라면 </span>
                <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">);</span><span class="c1">//set에 넣어준다.</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="c1">//다음 loop에서는 현재 노드가 prev가 되어야하므로 현재 노드를 prev에 할당한다.                </span>
            <span class="o">}</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">;</span><span class="c1">//iteration을 위해 추가</span>
        <span class="o">}</span>
          
          
    <span class="o">}</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>

    <p>​</p>
  </li>
</ul>

<h4 id="3-single-linked-list-뒤집기">3. Single linked list 뒤집기</h4>

<ul>
  <li>
    <p>이번엔 감을 좀 잡은 것 같았는데 아쉽다. hashSet에서 getter를 어떻게 써야하는 지 몰라서 시간 내에 못풀었다.</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td>
<td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
          
        <span class="n">Node</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//이전 노드</span>
        <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="c1">//시작점</span>
          
        <span class="k">while</span><span class="o">(</span><span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
        <span class="o">}</span>
          
        <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
          
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">set</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span><span class="c1">//여기가 에러 ㅠㅠ 이것만 풀면 해결인데!</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"[ "</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="s">" "</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">str</span> <span class="o">+=</span> <span class="s">"]"</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>모범 답안</p>

    <p>원리는 비슷한데.. 역시 훨씬 짧고 간결하다. 그러나 이 답은 비효율적이다. Node를 새로 만들기 때문에. 더 잘 최적화하면 iterator로 한다고 하는 거보니, 내가 처음에 생각한 예제가 맞는듯.</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td>
<td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">Node</span> <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="c1">// Node oldHead에 Node head 값을 복사해 놓고,</span>
        <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//Node head값을 null로 바꿔서 head를 지워버린다.</span>
          
		<span class="c1">//Node n에 Node oldHead 값을 할당. Node n이 null이 아니라면 반복문 실행. Node n은 현재 Node n이 참조하고있는 다음 Node의 값을 할당(참조 값이므로 얕은 복사.</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">=</span><span class="n">oldHead</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">){</span> 
            <span class="n">addToHead</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span><span class="c1">//일단 newNode는 int data, Node next를 가지고 있음.</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span><span class="c1">//newNode의 data는 매개변수 n으로 할당</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span><span class="c1">//newNode의 next에는 Node head를 가리키는 주소값 할당</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span><span class="c1">//Node head를 Node newNode의 값으로 변경</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"[ "</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="s">" "</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">str</span> <span class="o">+=</span> <span class="s">"]"</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>

    <p>​</p>
  </li>
</ul>

<p>!!! Node의 클래스 정의가 int data; Node next;라는 것을 지금 알았다.. next가 자료 값이 아니었구나 ㅠㅠ 즉 next는 다음 노드의 참조 주소를 가지고 있는 pointer이고 직접 자료 값을 가지고 있는 것이 아니다! 이것이 제일 중요. 내가 이해를 못하고 있던 부분이다.</p>

<h4 id="4-single-linked-list에서-뒤에서-k번째-원소를-반환하는-함수-구현하기">4. Single linked list에서 뒤에서 K번째 원소를 반환하는 함수 구현하기</h4>

<ul>
  <li>
    <p>맨 끝 원소는 0번째 원소이다.</p>
  </li>
  <li>
    <p>드디어 한 문제 풀었다 ㅠㅠ 이번에는 시간 생각하지 않고 계속 풀었다. next 변수의 데이터 타입이 Node라는 것을 간과해서 제대로 생각하지 못했던 것이 큰 원인이었다.</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td>
<td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(){</span>
        <span class="n">Node</span> <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">=</span><span class="n">oldHead</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">){</span>
            <span class="n">addToHead</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">kthToLast</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//즉 Node를 반환하니까, k-1번째 Node의 next를 반환하면 되지 않나? index를 쓰려면 헬퍼함수가 필요할 듯.index 변수에 영향을 받지 않으려면 자기 자신을 재귀하면 안된다. 헬퍼함수만 재귀해야 함.</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">reverse</span><span class="o">();</span>
        <span class="n">Node</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">=</span><span class="n">head</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">idx</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>모범답안</p>

    <p>k 번째가 0부터 시작하는지 1부터 시작하는지 꼭 물어볼 것.</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td>
<td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">kthToLast</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span> 
        <span class="k">if</span><span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span> <span class="c1">//k가 음수가 들어오면 안된다. null을 반환할지 exception을 반환할지는 면접관한테 물어볼 것.</span>
        	<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
      	<span class="n">Node</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="c1">//iteration을 도울 포인트</span>
        <span class="n">Node</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="c1">//두 사람이 달리는 데 앞 사람이 10미터 앞에서 출발하면, 앞 사람이 100미터에 다다랐을 때 뒷 사람은 90미터에 다다른 상태이다. 그리고 이 두 사람의 차이가 10미터인데 우리가 얻길 원하는 값이 바로 이 10미터이다. 이런 방식으로 원하는 값을 구하는 방법을 러너기법이라고 한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span><span class="c1">//우선 n2를 k만큼 달리게 한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">n2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span><span class="c1">// 뒤에서 15번째를 구하라고 했는데 k가 10개밖에 없다면 반환 값이 없다. 이 부분도 없으면 null을 반환하도록 처리해주어야한다.</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n2</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span><span class="c1">//앞의 for문에서 n2는 이미 k만큼 달려서 앞서 있는 상황이다. 이제 n1이 n2와 같은 속도로 달리면 k만큼의 차이를 가지고 계속 달리게 된다. n2가 끝에 도달할 때까지 달린 후, n2와 n1의 차이를 얻으면 된다.</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n1</span><span class="o">;</span><span class="c1">//둘의 차이는 k만큼 return이 되므로 n1을 반환하면 된다.</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h4 id="5-single-linked-list에서-회문palindrome판별하기">5. Single linked list에서 회문(palindrome)판별하기</h4>

<ul>
  <li>회문이랑 순서를 뒤집어도 내용이 같은 것을 의미한다.</li>
  <li>“noon”, “level”, “civic”등은 회문이다.</li>
  <li>
    <p>본 문제에서는 리스트에 정수가 담겨 있으니, 1-&gt;2-&gt;3-&gt;2-&gt;1와 같은 경우 회문으로 판별한다.</p>
  </li>
  <li>
    <p>내 답안. Stack으로 맞게 구현한 것 같은데, 어디서 오류가 나는지 종잡을 수가 없다.</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
<td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">()</span> <span class="o">{</span>
          
        <span class="n">Stack</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">();</span>
          
        <span class="c1">//stack에 모두 추가</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">=</span><span class="n">head</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">){</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="o">}</span>
          
        <span class="c1">//stack에서 꺼내면서 다시 list의 처음부터 비교</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">=</span><span class="n">head</span><span class="o">;</span> <span class="n">n</span><span class="o">!=</span><span class="kc">null</span><span class="o">;</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>        

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
          
        <span class="c1">//이 두상태가 같으면 true, 다르면 false</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>모범답안
Stack도 써야하고, List도 써야하므로 둘 다 확인이 가능하여 자주 출제된다.
현재 문제에서는 Node.java의 멤버 변수가 String이 아니라 Integer이므로 숫자로 생각하면 되고, <u>스택에 하나씩 넣었다가 중간부터 빼야하므로 홀수 일 때 중간이 어딘지도 알아야한다.</u>-&gt; 내가 몰랐던 부분이 이부분이네. 중간부터 빼야하나? 왜? 스택은 위에서 부터 빼는거 아닌가..?
그냥 총체적으로 내가 너무 쉽게 생각하고 있었다. 코드 자체를 다시 봐야 할 듯.</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td>
<td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//더블 러너 기법 사용</span>
        <span class="n">Node</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> 
        <span class="n">Node</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
          
        <span class="c1">//Integer를 받는 스택 생성</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
          
        <span class="c1">//loop를 한 번 돈다. n1은 한 칸씩, n2는 두 칸씩 가므로 차이가 절반이 난다. 따라서 n2가 마지막에 도달았을 때는 n1이 절반만 들어간 상태이다. 그림으로 그려서 설명을 해주면 좀 이해가 될텐데 말로 이해하려니 좀 어렵다. 책을 찾아봐야 할 듯 아하 이해했다. 1:2, 2:4, 3:6, 4:8 이런 식으로 2배씩 커지니까 두 배차이가 나는 것이 맞다! 따라서 n2과 n1의 차이는 절반! </span>
        <span class="k">while</span><span class="o">(</span><span class="n">n2</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">n2</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">n1</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//그리고 홀수일 때는 반복문이 돌아가지 않고 종료되므로 한칸 더 다음 으로 이동시켜야 정확히 중간에 n1이 위치한다.</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
          
        <span class="c1">//이제 스택에 넣은 중간 지점을 제외한 절반의 값을 위에서 부터 하나씩 빼면서 기존의 절반의 값과 처음부터 순서대로 비교하면 된다. 만약 이 값이 틀리면 false 반환이고 while문이므로 다음 값으로 기준점 이동하기 위해 n1을 n1.next로 변경!</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="n">n1</span><span class="o">.</span><span class="na">data</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<p>###</p>

  </article>
</div>

<!-- <div class="share-buttons">
  <h6>Share on: </h6>
  <ul>
    <li>
      <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/algorithm/2018/04/04/Linked-List-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7.html" class="twitter btn" title="Share on Twitter"><i class="fa fa-twitter"></i><span> Twitter</span></a>
    </li>
    <li>
      <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/algorithm/2018/04/04/Linked-List-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7.html" class="facebook btn" title="Share on Facebook"><i class="fa fa-facebook"></i><span> Facebook</span></a>
    </li>
    <li>
      <a href="https://plus.google.com/share?url=http://localhost:4000/algorithm/2018/04/04/Linked-List-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7.html" class="google-plus btn" title="Share on Google Plus"><i class="fa fa-google-plus"></i><span> Google+</span></a>
    </li>
    <li>
      <a href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/algorithm/2018/04/04/Linked-List-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7.html" class="hacker-news btn" title="Share on Hacker News"><i class="fa fa-hacker-news"></i><span> Hacker News</span></a>
    </li>
    <li>
      <a href="https://www.reddit.com/submit?url=http://localhost:4000/algorithm/2018/04/04/Linked-List-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB-%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7.html" class="reddit btn" title="Share on Reddit"><i class="fa fa-reddit"></i><span> Reddit</span></a>
    </li>
  </ul>
</div> -->


<div id="disqus_thread"></div>
</div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://https-youduk-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


        <footer>
  © 2018 Ducku Salon. Powered by <a href="https://jekyllrb.com/">Jekyll</a>, <a href="https://github.com/renyuanz/leonids/">customized with leonids theme</a> <i class="fa fa-heart heart-icon"></i>
</footer>

<!-- Channel Plugin Scripts -->
<script>
  ;window.channelPluginSettings = {
    "pluginKey": "9de17a11-abe2-455f-a49c-1c7da4fa312c"
  };
  (function() {
    var w = window;
    if (w.ChannelIO) {
      return (window.console.error || window.console.log || function(){})('ChannelIO script included twice.');
    }
    var d = window.document;
    var ch = function() {
      ch.c(arguments);
    };
    ch.q = [];
    ch.c = function(args) {
      ch.q.push(args);
    };
    w.ChannelIO = ch;
    function l() {
      if (w.ChannelIOInitialized) {
        return;
      }
      w.ChannelIOInitialized = true;
      var s = document.createElement('script');
      s.type = 'text/javascript';
      s.async = true;
      s.src = 'https://cdn.channel.io/plugin/ch-plugin-web.js';
      s.charset = 'UTF-8';
      var x = document.getElementsByTagName('script')[0];
      x.parentNode.insertBefore(s, x);
    }
    if (document.readyState === 'complete') {
      l();
    } else if (window.attachEvent) {
      window.attachEvent('onload', l);
    } else {
      window.addEventListener('DOMContentLoaded', l, false);
      window.addEventListener('load', l, false);
    }
  })();
</script>
<!-- End Channel Plugin -->        
      </div>
    </div>
  </div>
  <script id="dsq-count-scr" src="//https-youduk-github-io.disqus.com/count.js" async></script>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


    
</body>

</html>
