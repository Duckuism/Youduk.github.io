<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-121414052-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-121414052-1');
</script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>20180408 TIL</title>
  <meta name="description" content="">

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/til/2018/04/08/20180408.html">
  <link rel="alternate" type="application/rss+xml" title="Ducku Salon" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>

<body>
  <script id="dsq-count-scr" src="//https-youduk-github-io.disqus.com/count.js" async></script>
  <div class="row">
    <div class="col s12 m12">
      <div class="table cover">
        
<div class="cover-card table-cell table-middle">
  
  <img src="http://localhost:4000/img/authorLogo.jpeg" alt="" class="avatar">
  
  <a href="http://localhost:4000/" class="author_name">Ducku Salon</a>
  <span class="author_job">portfolio & Tech blog</span>
  <span class="author_bio mbm">Dreams are not dreamt, they are commplished.</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
                                                                           
    </ul>
  </nav>
  <script type="text/javascript">
  // based on https://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('rnejrl123456@gmail.com', 'Hello from website');</script>
      </li>
    
    
    <li><a href="https://facebook.com/originducku" class="social-link-item" target="_blank"><i class="fa fa-fw fa-facebook"></i></a></li>
    
    <li><a href="https://linkedin.com/in/youduk-han-2bbb94108" class="social-link-item" target="_blank"><i class="fa fa-fw fa-linkedin"></i></a></li>
    
    
    
    
    <li><a href="https://github.com/Youduk" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m12">
      <div class="post-listing">
        <div class="post-container">
<a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="20180408 TIL">20180408 TIL</h1>
    <span class="post-meta">
      <span class="post-date">
        8 APR 2018
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    19 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <h2 id="current-projects-and-challenges-in-progress">Current projects and challenges in progress</h2>

<ul>
  <li>JS스터디
    <ul>
      <li>react / TDD / elastic search / GCP</li>
    </ul>
  </li>
  <li>ES6 책 읽기</li>
  <li>해외 취업 스터디
    <ul>
      <li>레쥬메 수정 후 헤드헌터한테 보내기(이번주)</li>
      <li>자기소개 영상 찍기(다음주)</li>
    </ul>
  </li>
  <li>알고리즘(Java 동영상 강의 모두 듣고, 반복하면서 JS도 같은 사용례 찾아보기)</li>
  <li>자료구조</li>
</ul>

<h2 id="schedule">Schedule</h2>

<p><strong>운동 안 하는 날</strong></p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />(8:00~9:00) 기상 후 아침</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />(9:00~10:00) 알고리즘 문제 풀이 및 강의 듣기 (25x2 = 1시간)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />(10:00~11:00) 알고리즘 문제 풀이 및 강의 듣기 (25x2 = 1시간)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />(11:00~12:00) 알고리즘 문제 풀이 및 강의 듣기 (25x2 = 1시간)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />(12:00~13:00) 점심</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />(13:00~14:00) 알고리즘 문제 풀이 및 강의 듣기 (25x2 = 1시간)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />(14:00~15:00) 알고리즘 문제 풀이 및 강의 듣기 (25x2 = 1시간)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />(15:00~16:00) 알고리즘 문제 풀이 및 강의 듣기 (25x2 = 1시간)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />(16:00~17:00) 해외 취업 레쥬메 수정 (25x2 = 1시간)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />(18:00~) 저녁</li>
</ul>

<h2 id="today-check-list">Today Check List</h2>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />react-logger-lib 적용</li>
</ul>

<h2 id="tomorrow-check-list">Tomorrow Check List</h2>

<h2 id="today-i-learned">Today I learned</h2>

<h2 id="todays-algorithm">Today’s Algorithm</h2>

<h5 id="알고리즘은-20분-안에-모든-방법을-동원해서-못-풀면-바로-답을-보는-형식으로-연습">알고리즘은 20분 안에 모든 방법을 동원해서 못 풀면 바로 답을 보는 형식으로 연습!</h5>

<h3 id="queue">Queue</h3>

<p>https://dreamzelkova.tistory.com/entry/JAVA-%EC%BB%AC%EB%A0%89%EC%85%98%ED%81%90Queue</p>

<p>https://hyeonstorage.tistory.com/263</p>

<h4 id="1-스택으로-큐-순서-뒤집기">1. 스택으로 큐 순서 뒤집기</h4>

<ul>
  <li>
    <p>로직은 맞는 것 같은데 Queue를 어떻게 사용하는지모르겠다.</p>
  </li>
  <li>
    <p>제네릭스 부분에서 개념이 헷갈리는 것 같다.</p>
  </li>
  <li>
    <p>내 오답안</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReverseQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">){</span>
        <span class="c1">//매개변수로 q가 들어오고 이 q의 타입은 항상 T. 반환은 queue 타입으로 반환한다.</span>
        <span class="c1">//Queue에 있는 걸 순서대로 Stack에 넣었다가 다시 빼면서 Queue에 넣으면 순서가 바뀐다.</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>
          
        <span class="k">while</span><span class="o">(</span><span class="n">q</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="o">}</span>
          
        <span class="k">while</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">pull</span><span class="o">());</span>
        <span class="o">}</span>
          
        <span class="k">while</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
        <span class="o">}</span>
          
        <span class="k">return</span> <span class="n">queue</span><span class="o">;</span>
          
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>모범 답안</p>
  </li>
  <li>
    <p>큐와 스택은 내부에 데이터들이 저장 순서가 정해져있다.
아니 생각한건 다 똑같았는데 왜 아까는 안 됐지.. ㅠㅠ while문의 isEmpty대신 q.peek()!=null을 썼었는데 이 부분이 문제였나보다.</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReverseQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">){</span>
        <span class="c1">//큐가 들어가서 큐가 나온다. 즉, 순서가 뒤집혀서 나온다.(이 부분은 내가 이해한 부분이 맞는데.)</span>
        <span class="c1">//큐 =&gt; 스택 =&gt; 큐 라고 생각했던 로직도 맞다.</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>
          
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmty</span><span class="o">())</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h3 id="2-두-개의-stack으로-큐-구현하기">2. 두 개의 stack으로 큐 구현하기</h3>

<ul>
  <li>
    <p>기존 스택이 큐 순서대로 정렬되어있으므로</p>

    <ol>
      <li>기존 스택의 내용을 새 스택으로 옮긴다. (원래 스택의 순서와 같아짐)</li>
      <li>새 스택에 새로운 요소를 추가한다.</li>
      <li>새로운 요소가 추가된 새 스택의 내용을 기존의 스택으로 다시 옮긴다. (다시 큐의 순서로 돌아옴)</li>
      <li>어차피 요소를 추가할 때 순서를 바꿔서 저장하므로, poll은 그냥 기존 스택 맨 위에서 pop()하면 되고, size 같은 경우는 요소 추가, 제거 시에 index를 계산해주면 된다.</li>
    </ol>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>//일단 첫 번째 스택에 들어오는 요소를 다 넣고,
//다시 pop()하여 두 번째 스택에 요소를 다 넣은 후,
//두 번째 스택에서 pop()하면 queue와 순서는 같다.
//그런데 문제에서 원하는 것이 이 방법이 맞을까?
public class MyQueue<T> {</T></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre>Stack&lt;T&gt; stack1;
Stack&lt;T&gt; stack2;
int size = 0;
  
public MyQueue() {
    stack1 = new Stack&lt;T&gt;();
    stack2 = new Stack&lt;T&gt;();
}
  
public void offer(T element) { //q의 offer는 
    //스택이 비어있다면 그냥 넣는다.
    if(stack1.isEmpty()){
        stack1.push(element);
    }else{//스택이 비어있지 않다면
        //기존 스택의 내용을 새 스택으로 옮긴다. 순서가 바뀜
        while(!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
          
        //새 스택 맨 위에 새로운 요소 추가
        stack2.push(element);
          
        //다시 기존 스택으로 모든 요소를 옮긴다. 순서가 바뀜(큐와 같아짐))
        while(!stack2.isEmpty()){
            stack1.push(stack2.pop());
        }
    }
    size++;
}
  
public T poll() {//q의 poll은 첫 번째 요소가 첫 번째로 나오는 것. 마지막 요소는 마지막에 나와야 한다.
    if(stack1.isEmpty()){
        throw new RuntimeException("Nothing to poll");
    }
      
    size--;
    return stack1.pop();
}
  
public int size() {//q의 사이즈는 넣으면서 index를 올리면 될 듯?
    return size;
} } ~~~
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>모범 답안
너..너무 간단하다. 굉장히 짧네 ㅠㅠ</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
      
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">stack1</span><span class="o">;</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">stack2</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      
    <span class="kd">public</span> <span class="nf">MyQueue</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">stack1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>
        <span class="n">stack2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>
    <span class="o">}</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">offer</span><span class="o">(</span><span class="n">T</span> <span class="n">element</span><span class="o">)</span> <span class="o">{</span> 
		<span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
    <span class="o">}</span>
      
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">poll</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                <span class="n">s2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="k">return</span> <span class="n">s2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="o">}</span>
      
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h3 id="treegraph-이론-학습">TREE&amp;GRAPH 이론 학습</h3>

<p><img src="/Img/2018-04-08-01.png" alt="" /></p>

<p>상위 노드 : 부모 노드(parent)</p>

<p>하위 노드 : 자손 노드(children)</p>

<p>같은 라인의 노드 : 형제 노드(sibling)</p>

<p><img src="/Img/2018-04-08-02.png" alt="" /></p>

<p>트리는 크게 바이너리 트리와 일반 트리가 있다.</p>

<p>바이너리 트리 : 자식이 2개만 있는 것</p>

<p>일반 : 자식이 몇 개 있을지 모르니까 리스트나 배열형태로 가지고 있다.</p>

<h4 id="tree-문제-핵심-정리">Tree 문제 핵심 정리</h4>

<p><u>이진 트리가 아닌 트리는 잘 출제되지 않는다.</u></p>

<p>이진트리가 주어지면, 이진 탐색 트리인지 반드시 확인하자. (단순히 자식이 두 개인건가, 왼쪽으로 가면 작아지고 오른 쪽으로 가면 커지는가 등) 이 두개는 절대 같지 않다. 무조건 트리가 나오면 이 것부터 생각한다고 봐야한다.</p>

<p>Breadth first search(너비 우선 탐색), depth first search(깊이 우선 탐색) 정도는 알아두자. 이 코드는 그냥 외워라.</p>

<p>Tree의 balance를 맞춰주는 구현은 출제 빈도가 낮다.</p>

<p>균형잡힌 트리인 경우에 검색 시간은 O(logn)이다.(밸런스가 맞는다는 가정 하에) 이것도 암기해야한다.</p>

<p><img src="/Img/2018-04-08-03.png" alt="" /></p>

<p>면접관이 그래프와 트리의 차이가 무엇이냐고 물어볼 수 있다.</p>

<p>트리 : 그래프 중에 사이클이 허용되지 않는 그래프. 트리가 그래프의 특이한 형태이다.</p>

<h4 id="graph-문제-핵심-정리">Graph 문제 핵심 정리</h4>

<p>그래프 문제는 출제 빈도가 매우 낮다.</p>

<p>엣지와 노드가 나왔다고 그래프라고 단정하면 안된다.</p>

<p><u>혹시 트리로 풀 수 있는지 생각해봐라!!</u></p>

<p><strong>출제 문제들은 대부분 그래프 내에서의 탐색 문제이다.</strong></p>

<p>방향성이 있는 그래프인지 모호한 경우(제대로 기재되어있지 않은 경우), 질문해야 한다.</p>

<p>또한 그래프 문제가 너무 어렵다고 생각되면, 면접관한테 트리로 풀면 안되는지 물어볼 것. 그러라고 할 수도 있고 힌트가 되는 가이드를 줄 수도 있다.</p>

<p>그래프 문제는 굉장히 어려우므로 30분~1시간 안에 푸는 용도로는 어려운 게 나오지 않는다. 나와봤자 깊이우선검색, 너비검색 등의 간단한 문제이다.</p>

<h4 id="1-binary-tree에서-최대값-찾기">1. Binary Tree에서 최대값 찾기</h4>

<ul>
  <li>
    <p>모든 노드가 값을 가지고 있음에 주의한다.</p>
  </li>
  <li>
    <p>왼쪽 맨 끝부터 비교를 하고 싶은데, 몇 차수인지 모르는 Tree의 맨 끝의 노드까지 어떻게 접근해야할 지를 모르겠다. 처음에 기준점 head가 주어지는데 마냥 계속 접근할 수는 없고, 어떤 조건문을 줘서 while문을 돌려야 할 것 같다. -&gt; 처음에 재귀로 풀어야할 것 같다고 생각했었는데, 재귀였다!!</p>
  </li>
  <li>
    <p>모범 답안
바이너리트리가 나오면? <strong>바이너리트리인지, 바이너리 서치트리인지 확인해라!!</strong>-&gt; 안함..ㅋㅋ..
바이너리 서치트리라는 말이 없다. 즉 왼쪽으로 내려가면 작아지거나 오른쪽으로 내려가면 커지거나 하는 것이 없다는 것. 어디에 어떤 값이 있을지 모른다는 얘기</p>
  </li>
  <li>
    <p>현재 노드의 값과 왼쪽 노드로 내려갔을 때 최대값, 서브트리로 내려갔을 때 최대값 이 세 값의 MAX 값을 반환해주면 된다.</p>
  </li>
  <li>
    <p>아.. 아니 재귀를 이렇게 간단히가 가능하구나.. Math.max를 쓴다는 게 일단 좀 편법이긴 하지만 굉장히 간단하긴 하다. 하지만 생각해내긴 어려웠을 듯. 반복문으로 구현할 수는 없다고 생각한다.</p>
  </li>
  <li>
    <p>재귀 함수를 잘 이해하는지, 트리를 잘 이해하고 있는지를 물어보는 문제이므로 얼마든지 출제될 수 있는 문제이다!</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinaryTreeHandler</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getMax</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span> <span class="c1">//-인피니트 값은 나오지 않는다고 가정, 재귀 호출 시 종료 조건이 되어줄 것이다.</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="n">getMax</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span> <span class="c1">//종료 조건이 위에 있다. root가 null이 될 때까지 계속 재귀호출한다. 그리고 왼쪽으로 하나 내려갈 때마다 다시 왼쪽 오른쪽 재귀함수가 발생한다.  </span>
        <span class="kt">int</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="n">getMax</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span><span class="c1">//종료 조건이 위에 있다. root가 null이 될 때까지 계쏙 재귀 호출한다. 그리고 오른쪽으로 하나 내려갈 때마다 다시 왼쪽 오른쪽 재귀함수가 발생한다.</span>
        <span class="kt">int</span> <span class="n">childMax</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">leftMax</span><span class="o">,</span> <span class="n">rightMax</span><span class="o">);</span><span class="c1">//위의 두 가지 재귀함수가 반환한 값을 비교한다. 마지막에서 한 번 비교가 아니라 재귀함수 마다 비교하므로 결국 왼쪽 오른쪽을 모두 비교하는 것.</span>
        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">childMax</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">data</span><span class="o">);</span><span class="c1">// 그리고 마지막에 모든 재귀함수의 반환 값을 가지고 비교한 childMax의 값과 처음 root의 data 값을 비교해서 무엇이 큰 지를 반환하면 된다.</span>
          
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h4 id="2-binary-tree의-balance가-맞는지-판별하기">2. Binary Tree의 Balance가 맞는지 판별하기</h4>

<ul>
  <li>
    <p>Balance가 맞는 상태는 모든 노드의 자식들의 높이 차이가 2이상 나지 않는 것이다.(1은 허용, 2는 불허)</p>
  </li>
  <li>
    <p>생각은 좀 해봤는데, 재귀 함수를 못짜겠다 ㅠㅠ</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinaryTreeHandler</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//역시나 재귀일 것인데. 재귀에 들어가면서 높이를 변수로 같이 넘기고, 마지막에 반환하도록 하면?</span>
        <span class="c1">//근데 마찬가지로 반환할 때 Math.max 값으로 반환하는 차수를 비교하고 차이가 2이상이면 바로 return false하면 될 듯!</span>
        <span class="c1">//아니면 마지막에 종료 조건 전에 배열에 node의 차수를 집어넣고 정렬한 후 맨 앞 요소와 맨 뒤요소의 차이가 2이상이면 false는 어떨까.</span>
        <span class="c1">//위 방법은 문제가 자바는 동적으로 배열에 요소 추가가 안 된다. 배열 생성시 무조건 사이즈를 지정해야 해서.. 굉장히 비효율적. 이 방법은 패쓰.</span>
          
        <span class="c1">//현재 isBalanced 함수는 타입이 boolean이라 true/false를 반환해야 하기 때문에 자기 자신을 호출하면 int값인 높이를 비교할 수 없다.</span>
        <span class="c1">//따라서 헬퍼함수가 필요할 듯</span>
        <span class="kt">int</span> <span class="n">stand</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span><span class="c1">//기준점</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span><span class="c1">//처음에 하나라도 있으면 차수는 1</span>
          
        <span class="k">return</span> <span class="nf">isBalancedDepth</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">depth</span><span class="o">);</span>
          
    <span class="o">}</span>
      
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">){</span>

    <span class="o">}</span>
      
      
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>모범 답안
바로 구현하기가 쉽지 않다. 왼쪽 자식의 높이 구하고, 오른쪽 자식의 높이 구하고 이 차이를 보고, 위에 가서 또 계속 반복해야한다. 생각보다 복잡하다. 하지만 방법은 생각했던 것과 같다.</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinaryTreeHandler</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">){</span>
          
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">isBalancedHelper</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">isBalancedHeper</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">left</span><span class="o">);</span> <span class="c1">//isBalancedHelper가 높이를 반환한다고 가정하면 왼쪽의 높이</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">isBalancedHeper</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
          
        <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">);</span> <span class="c1">//절대값 함수</span>
        <span class="k">if</span><span class="o">(</span><span class="n">diff</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">){</span><span class="c1">//높이가 다 양수인데, 밸런스가 안 맞을 때는 야수가 아닌 수를 반환해주면 어떨까?</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h4 id="3-오름-차순으로-정렬된-배열을-binary-search-tree로-구현하기">3. 오름 차순으로 정렬된 배열을 Binary Search Tree로 구현하기</h4>

<ul>
  <li>
    <p>생성된 트리의 높이는 최소한으로 한다.</p>
  </li>
  <li>
    <p>[1,2,3]이 입력으로 들어오면 root는 2값을 가지고 왼쪽 자식은 1, 오른쪽 자식은 3을 가지는 값을 가진다.</p>
  </li>
  <li>
    <p>못풀었다 ㅠㅠ</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BSTBuilder</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Node</span> <span class="nf">build</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//주어진 예시에 충실하려면 왼쪽 자식부터 채우는 형태여야 맞다.</span>
        <span class="c1">//[1, 3, 5, 7, 9, 11, 13]</span>
        <span class="c1">//     1</span>
        <span class="c1">//  3     5</span>
        <span class="c1">// 7 11  9 13</span>
        <span class="c1">// 요런 느낌! </span>
        <span class="c1">//1. 일단 build 함수에 배열이 들어온다.</span>
        <span class="c1">//2. 처음에는  [1]이 root left=[0],right=[2]</span>
        <span class="c1">//3. 다음에는 [0].left=[3], [2].left=[4], [0].right=[5], [2].right=[6]</span>
        <span class="c1">//이런 식으로 돌아갈 것.</span>
        <span class="c1">//반환값은 Node인데.. 트리를 반환하는 것이 노드를 반환하는 게 맞나? 반환 값이 Node면 헬퍼함수는 필요 없을 것 같은데.</span>
        <span class="c1">//어렵네ㅠㅠ</span>
        <span class="c1">//뭔가 처음에 [1]을 root로 지정한 다음, 배열 맨 앞부터 왼쪽부터 정렬하는 느낌인데? (어차피 높이가 최소한이므로.)</span>
          
    <span class="o">}</span>
      
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Node</span> <span class="nf">buildTree</span><span class="o">()</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>모범 답안
<strong>Binary Tree가 아니고 Binary Search Tree라는 것에 주의 할 것!!</strong></p>
  </li>
  <li>
    <p>이진 트리와 이진 검색 트리의 차이점</p>

    <ul>
      <li>https://code.i-harness.com/ko/q/615ac7</li>
      <li>이진 트리
        <ul>
          <li>두 개의 하위 참조만 가질 수 있는 노드로 구성된 데이터 구조</li>
        </ul>
      </li>
      <li>이진 검색 트리
        <ul>
          <li>이진 트리 데이터 구조의 특수한 형태</li>
          <li>왼쪽 자식 노드가 부모 노드보다 작음</li>
          <li>오른쪽 자식 노드가 부모 노드보다 큼</li>
          <li><u>이래서 오름차순에서 가운데가 root고 왼쪽 절반이 왼쪽 자식이고 오른쪽 절반이 왼쪽 자식이었던 것!!!!</u></li>
        </ul>
      </li>
    </ul>

    <p>높이가 최소한으로 되어 있지 않으면 오른쪽이나 왼쪽으로 링크드리스트 만들면 끝남. 문제의 의미가 없음.
반을 쪼개서 가운데는 root로 올리고, 왼쪽 절반은 왼쪽 자식으로 오른쪽 절반은 오른쪽 자식으로!
우선 Binary Search 하고 비슷하니까, 뭔가 Recursive 콜을 해야하고, 반씩 쪼개 나가니까 범위가 있는거고, 범위가 있으니까 숫자가 두 개 필요하다. 따라서 여러 매개변수를 넘길 헬퍼함수가 필요.</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="c1">//BSTBuilder.java</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BSTBuilder</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Node</span> <span class="nf">build</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">){</span>
        <span class="k">return</span> <span class="nf">buildRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">);</span><span class="c1">//a는 기존에 주어진 배열, 범위가 있어야 하는데 시작은 0, 끝은 a.legnth-1</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Node</span> <span class="nf">buildRec</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">){</span>
        <span class="c1">//Binary Search할 때 index에서 시작 값이 끝 값보다 커질 수가 없는데 이런 불변식이 깨지는 경우가 될 때는 이미 검색이 끝났다는 얘기. 따라서 할 게 없다. 뒤집어졌으므로 BST로 만들어서 리턴해줄 수가 없다.</span>
        <span class="k">if</span><span class="o">(</span><span class="n">low</span><span class="o">&gt;</span><span class="n">high</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//중간 값 찾기</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span> <span class="c1">//평균값으로 가운데 index를 찾는다.</span>
          
        <span class="n">Node</span> <span class="n">left</span> <span class="o">=</span> <span class="n">buildRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//m은 새로운 root가 될 꺼니까 -1; 즉, 가운데 값과 비교하여 작은 수 중, 차이가 제일 적은 바로 왼쪽 요소가 root가 되는 것</span>
        <span class="n">Node</span> <span class="n">right</span> <span class="o">=</span> <span class="n">buildRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span><span class="c1">//가운데 값과 비교하여 큰 수중, 차이가 제일 적게 나는 바로 오른쪽 요소가 다시 root가 되는 것</span>
          
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">m</span><span class="o">],</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span><span class="c1">//Node.java 클래스의 생성자를 이용. 중간값, left노드, right노드.</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="c1">//Node.java</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">left</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">right</span><span class="o">;</span>
      
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
      
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">Node</span> <span class="n">l</span><span class="o">,</span> <span class="n">Node</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h4 id="4-주어진-binary-tree가-binary-search-tree인지-판별하기">4. 주어진 Binary Tree가 Binary Search Tree인지 판별하기</h4>

<ul>
  <li>
    <p>왼쪽 자식은 부모의 값에 비해 같거나 작다.</p>
  </li>
  <li>
    <p>오른쪽 자식은 부모의 값에 비해 크다.</p>
  </li>
  <li>
    <p>못 풀었다 ㅠㅠ</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TreeHandler</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBST</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">return</span> <span class="nf">isBSTRec</span><span class="o">(</span><span class="n">root</span><span class="o">);</span> <span class="c1">// 현재 root와 바로 인접한 왼쪽 자식, 오른쪽 자식을 넘김</span>
    <span class="o">}</span>
      
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBSTRec</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">){</span> 
        <span class="c1">//현재 root와 바로 인접한 왼쪽 자식, 오른쪽 자식을 받음. </span>
        <span class="c1">//왼쪽 자식과 오른쪽 자식, root를 비교한 후, </span>
        <span class="c1">//다시 recursion으로 왼쪽 자식의 왼쪽 자식, 오른쪽 자식, 오른쪽 자식의 왼쪽 자식, 오른쪽 자식을 넘기는 식으로 recursion이 진행되야 함. </span>
        <span class="c1">//그러면 넘기는 root는 받았던 왼쪽 자식, 오른쪽 자식으로 바뀌어야 함.</span>
          
    <span class="o">}</span>
      
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>모범 답안
간단해보이지만 정말 많이 틀리는 문제이다. 대부분의 문제들은 조건들을 if문으로 넣으면 상관이 없는데, 자식은 내려가면서 그 부모들의 영향을 계속 받는다. 할아버지 노드가 10일 때, 아버지 노드가 10보다 작아야 되고, 손자 노드들도 10보다 작아야 되는 것. 즉 계속 이렇게 영향을 받고 있는 상태이므로 조건문이 아니라 범위 탐색을 해야하는 문제다. <u>단순히 부모 자식만 비교하면 안 된다.</u></p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TreeHandler</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBst</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">return</span> <span class="nf">isBstRec</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span> <span class="c1">//범위탐색이. Binary Search할 때 low와 high, min과 max 값으로 하는 것과 똑같이 하면 된다. </span>
    <span class="o">}</span>
      
    <span class="c1">// 불변식 : min &lt; node.data &lt;= max</span>
    <span class="c1">// 최소값보다 크고, 최대값보다 작거나 같다.</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBstRes</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">min</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span> <span class="c1">//노드가 하나면 자식이 없으니까 조건을 위배할 일이 없으므로 true를 반환한다.</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span> <span class="o">&lt;=</span> <span class="n">min</span> <span class="o">||</span> <span class="n">node</span><span class="o">.</span><span class="na">data</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">){</span> <span class="c1">//불변식의 반대</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
		<span class="kt">boolean</span> <span class="n">leftBst</span> <span class="o">=</span> <span class="n">isBstRec</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">min</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">);</span><span class="c1">//min부터 node.data의 범위 제한이 생긴다.</span>
		<span class="kt">boolean</span> <span class="n">rightBst</span> <span class="o">=</span> <span class="n">isBstRec</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span><span class="c1">//node.data부터 max의 범위 제한이 생긴다.        </span>
        <span class="k">return</span> <span class="n">leftBst</span> <span class="o">&amp;&amp;</span> <span class="n">rightBst</span><span class="o">;</span> <span class="c1">//양쪽이 다 Binary Search를 만족하면 되는 것.</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>​</p>
  </li>
</ul>

  </article>
</div>

<!-- <div class="share-buttons">
  <h6>Share on: </h6>
  <ul>
    <li>
      <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/til/2018/04/08/20180408.html" class="twitter btn" title="Share on Twitter"><i class="fa fa-twitter"></i><span> Twitter</span></a>
    </li>
    <li>
      <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/til/2018/04/08/20180408.html" class="facebook btn" title="Share on Facebook"><i class="fa fa-facebook"></i><span> Facebook</span></a>
    </li>
    <li>
      <a href="https://plus.google.com/share?url=http://localhost:4000/til/2018/04/08/20180408.html" class="google-plus btn" title="Share on Google Plus"><i class="fa fa-google-plus"></i><span> Google+</span></a>
    </li>
    <li>
      <a href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/til/2018/04/08/20180408.html" class="hacker-news btn" title="Share on Hacker News"><i class="fa fa-hacker-news"></i><span> Hacker News</span></a>
    </li>
    <li>
      <a href="https://www.reddit.com/submit?url=http://localhost:4000/til/2018/04/08/20180408.html" class="reddit btn" title="Share on Reddit"><i class="fa fa-reddit"></i><span> Reddit</span></a>
    </li>
  </ul>
</div> -->


<div id="disqus_thread"></div>
</div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://https-youduk-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


        <footer>
  &copy; 2018 Ducku Salon. Powered by <a href="https://jekyllrb.com/">Jekyll</a>, <a href="https://github.com/renyuanz/leonids/">customized with leonids theme</a> <i class="fa fa-heart heart-icon"></i>
</footer>

<!-- Channel Plugin Scripts -->
<script>
  ;window.channelPluginSettings = {
    "pluginKey": "9de17a11-abe2-455f-a49c-1c7da4fa312c"
  };
  (function() {
    var w = window;
    if (w.ChannelIO) {
      return (window.console.error || window.console.log || function(){})('ChannelIO script included twice.');
    }
    var d = window.document;
    var ch = function() {
      ch.c(arguments);
    };
    ch.q = [];
    ch.c = function(args) {
      ch.q.push(args);
    };
    w.ChannelIO = ch;
    function l() {
      if (w.ChannelIOInitialized) {
        return;
      }
      w.ChannelIOInitialized = true;
      var s = document.createElement('script');
      s.type = 'text/javascript';
      s.async = true;
      s.src = 'https://cdn.channel.io/plugin/ch-plugin-web.js';
      s.charset = 'UTF-8';
      var x = document.getElementsByTagName('script')[0];
      x.parentNode.insertBefore(s, x);
    }
    if (document.readyState === 'complete') {
      l();
    } else if (window.attachEvent) {
      window.attachEvent('onload', l);
    } else {
      window.addEventListener('DOMContentLoaded', l, false);
      window.addEventListener('load', l, false);
    }
  })();
</script>
<!-- End Channel Plugin -->        
      </div>
    </div>
  </div>
  <script id="dsq-count-scr" src="//https-youduk-github-io.disqus.com/count.js" async></script>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


    
</body>

</html>
